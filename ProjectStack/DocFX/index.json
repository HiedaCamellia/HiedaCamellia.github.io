{
  "CONTRIBUTING.html": {
    "href": "CONTRIBUTING.html",
    "title": "Contributing | ProjectStack",
    "keywords": "Contributing Thank you for taking the time to read this contributing guide and for showing interest in helping this project! Getting Started Need a helping hand to get started? Check out these resources! Discord Server Chickensoft Website Please read our code of conduct. We do our best to treat others fairly and foster a welcoming environment. Project Setup This is a C# nuget package, for use with the .NET SDK 6 or 7. As such, the dotnet tool will allow you to restore packages and build projects. Coding Guidelines Your IDE should automatically adhere to the style guidelines in the provided .editorconfig file. Please try to keep lines under 80 characters long whenever possible. We try to write tests for our projects to ensure a certain level of quality. We are willing to give you support and guidance if you need help! Code of Conduct We follow the Contributor Covenant. In short: We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation."
  },
  "README.html": {
    "href": "README.html",
    "title": "ProjectStack | ProjectStack",
    "keywords": "ProjectStack C# game template for Godot 4 with debug launch configurations, testing (locally and on CI/CD), code coverage, dependency update checks, and spell check working out-of-the-box! ü•ö Getting Started This template allows you to easily create a C# game for Godot 4. Microsoft's dotnet tool allows you to easily create, install, and use templates. # Install this template dotnet new install ProjectStack # Generate a new project based on this template dotnet new chickengame --name \"MyGameName\" --param:author \"My Name\" cd MyGameName dotnet build üíÅ Getting Help Is this template broken? Encountering obscure C# build problems? We'll be happy to help you in the Chickensoft Discord server. üèù Environment Setup For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The Chickensoft Setup Docs describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations. VSCode Settings This template includes some Visual Studio Code settings in .vscode/settings.json. The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings. .NET Versioning The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows Renovatebot to provide your repository with automatic dependency update pull requests whenever a new version of GodotSharp is released. üë∑ Testing An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using GoDotTest and godot-test-driver. GoDotTest is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment. üèÅ Application Entry Point The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn. If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn. The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name). üö¶ Test Coverage Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required until coverlet releases a stable version with the fixes that allow it to work with Godot 4. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage. If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1 ‚èØ Running the Project Several launch profiles are included for Visual Studio Code: üïπ Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. üé≠ Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs, and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. ‚ö†Ô∏è It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. üß™ Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. üî¨ Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest, and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. ‚ö†Ô∏è It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json) before debugging the game. ‚ö†Ô∏è Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the Chickensoft Setup Docs. üè≠ CI/CD This game includes various GitHub Actions workflows to help with development. üö• Tests Tests run directly inside the GitHub runner machine (using chickensoft-games/setup-godot) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments (vulkan and/or opengl3) you want to run tests on in .github/workflows/visual_tests.yaml. Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in ProjectStack from the command line and passing in the relevant arguments to Godot so that GoDotTest can discover and run tests. üßë‚Äçüè´ Spellcheck A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml. The Code Spell Checker plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json. üóÇ Version Change The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in ProjectStack.csproj with the version you specify in the workflow's inputs. üì¶ Publish to Nuget The included workflow in .github/workflows/publish.yaml can be manually dispatched when you're ready to publish your package to Nuget. To publish to nuget, you need a repository or organization secret named NUGET_API_KEY that contains your Nuget API key. The NUGET_API_KEY must be a GitHub actions secret to keep it safe! üèö Renovatebot This repository includes a renovate.json configuration for use with Renovatebot. Renovatebot can automatically open pull requests to help you keep your dependencies up to date when it detects new dependency versions have been released. Because Godot has such a rapid release cycle, automating dependency updates can be a huge time saver if you're trying to stay on the latest version of Godot. Unlike Dependabot, Renovatebot is able to combine all dependency updates into a single pull request ‚Äî a must-have for Godot C# repositories where each sub-project needs the same Godot.NET.Sdk versions. If dependency version bumps were split across multiple repositories, the builds would fail in CI. The easiest way to add Renovatebot to your repository is to install it from the GitHub Marketplace. Note that you have to grant it access to each organization and repository you want it to monitor. The included renovate.json includes a few configuration options to limit how often Renovatebot can open pull requests as well as regex's to filter out some poorly versioned dependencies to prevent invalid dependency version updates. üê£ Package generated from a üê§ Chickensoft Template ‚Äî https://chickensoft.games"
  },
  "api/ProjectStack.CardTest.html": {
    "href": "api/ProjectStack.CardTest.html",
    "title": "CardTest Á±ª | ProjectStack",
    "keywords": "CardTest Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack Á®ãÂ∫èÈõÜ ProjectStack.dll public class CardTest : TestClass ÁªßÊâø object TestClass CardTest ÊûÑÈÄ†ÂáΩÊï∞ CardTest(Node) public CardTest(Node testScene) ÂèÇÊï∞ testScene Node ÊñπÊ≥ï Setup() [Setup(26)] public void Setup() SetupAll() [SetupAll(19)] public void SetupAll() TestBottomCards() [Test(46)] public void TestBottomCards() TestDisconnectTopCard() [Test(56)] public void TestDisconnectTopCard() TestTopCards() [Test(36)] public void TestTopCards()"
  },
  "api/ProjectStack.Command.CommandAdapter.html": {
    "href": "api/ProjectStack.Command.CommandAdapter.html",
    "title": "CommandAdapter Á±ª | ProjectStack",
    "keywords": "CommandAdapter Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Command Á®ãÂ∫èÈõÜ ProjectStack.dll [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Command/CommandAdapter.cs\")] public class CommandAdapter : Node ÁªßÊâø object GodotObject Node CommandAdapter Â±ûÊÄß Metatype Generated metatype information. public IMetatype Metatype { get; } Â±ûÊÄßÂÄº IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } Â±ûÊÄßÂÄº MixinBlackboard ÊñπÊ≥ï CreateNewCard(ResourceLocation) public void CreateNewCard(ResourceLocation id) ÂèÇÊï∞ id ResourceLocation CreateNewCard(string) public void CreateNewCard(string id) ÂèÇÊï∞ id string CreateNewCardStack(List<ResourceLocation>) public void CreateNewCardStack(List<ResourceLocation> ids) ÂèÇÊï∞ ids List<ResourceLocation> CreateNewCardStack(string[]) public void CreateNewCardStack(string[] ids) ÂèÇÊï∞ ids string[] GetCardMate(ResourceLocation) public ResourceLocation GetCardMate(ResourceLocation id) ÂèÇÊï∞ id ResourceLocation ËøîÂõû ResourceLocation GetCardMate(string) public ResourceLocation GetCardMate(string id) ÂèÇÊï∞ id string ËøîÂõû ResourceLocation GetRegisteredCardMetaIds() public string[] GetRegisteredCardMetaIds() ËøîÂõû string[] HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data."
  },
  "api/ProjectStack.Command.html": {
    "href": "api/ProjectStack.Command.html",
    "title": "ProjectStack.Command ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Command ÂëΩÂêçÁ©∫Èó¥ Á±ª CommandAdapter"
  },
  "api/ProjectStack.Common.Card.CardMeta.html": {
    "href": "api/ProjectStack.Common.Card.CardMeta.html",
    "title": "CardMeta Á±ª | ProjectStack",
    "keywords": "CardMeta Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Card Á®ãÂ∫èÈõÜ ProjectStack.dll public record CardMeta ÁªßÊâø object CardMeta ÊûÑÈÄ†ÂáΩÊï∞ CardMeta(ResourceLocation, string, string, ResourceLocation) public CardMeta(ResourceLocation Id, string Name, string Description, ResourceLocation Type) ÂèÇÊï∞ Id ResourceLocation Name string Description string Type ResourceLocation Â±ûÊÄß Description public string Description { get; init; } Â±ûÊÄßÂÄº string Id public ResourceLocation Id { get; init; } Â±ûÊÄßÂÄº ResourceLocation Name public string Name { get; init; } Â±ûÊÄßÂÄº string Type public ResourceLocation Type { get; init; } Â±ûÊÄßÂÄº ResourceLocation ÊñπÊ≥ï Create(string) public static CardMeta Create(string id) ÂèÇÊï∞ id string ËøîÂõû CardMeta"
  },
  "api/ProjectStack.Common.Card.CardMetaRegistrationHelper.html": {
    "href": "api/ProjectStack.Common.Card.CardMetaRegistrationHelper.html",
    "title": "CardMetaRegistrationHelper Á±ª | ProjectStack",
    "keywords": "CardMetaRegistrationHelper Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Card Á®ãÂ∫èÈõÜ ProjectStack.dll public class CardMetaRegistrationHelper ÁªßÊâø object CardMetaRegistrationHelper ÊûÑÈÄ†ÂáΩÊï∞ CardMetaRegistrationHelper(IServiceCollection) public CardMetaRegistrationHelper(IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ÊñπÊ≥ï Add(CardMeta) public CardMetaRegistrationHelper Add(CardMeta cardMeta) ÂèÇÊï∞ cardMeta CardMeta ËøîÂõû CardMetaRegistrationHelper End() public IServiceCollection End() ËøîÂõû IServiceCollection"
  },
  "api/ProjectStack.Common.Card.CardStack.html": {
    "href": "api/ProjectStack.Common.Card.CardStack.html",
    "title": "CardStack Á±ª | ProjectStack",
    "keywords": "CardStack Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Card Á®ãÂ∫èÈõÜ ProjectStack.dll public record CardStack : ICardStack ÁªßÊâø object CardStack ÂÆûÁé∞ ICardStack ÊûÑÈÄ†ÂáΩÊï∞ CardStack(IImmutableList<Card>) public CardStack(IImmutableList<Card> Cards) ÂèÇÊï∞ Cards IImmutableList<Card> Â±ûÊÄß Cards public IImmutableList<Card> Cards { get; init; } Â±ûÊÄßÂÄº IImmutableList<Card>"
  },
  "api/ProjectStack.Common.Card.ICardStack.html": {
    "href": "api/ProjectStack.Common.Card.ICardStack.html",
    "title": "ICardStack Êé•Âè£ | ProjectStack",
    "keywords": "ICardStack Êé•Âè£ ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Card Á®ãÂ∫èÈõÜ ProjectStack.dll public interface ICardStack Â±ûÊÄß Cards IImmutableList<Card> Cards { get; } Â±ûÊÄßÂÄº IImmutableList<Card>"
  },
  "api/ProjectStack.Common.Card.html": {
    "href": "api/ProjectStack.Common.Card.html",
    "title": "ProjectStack.Common.Card ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Common.Card ÂëΩÂêçÁ©∫Èó¥ Á±ª CardMeta CardMetaRegistrationHelper CardStack Êé•Âè£ ICardStack"
  },
  "api/ProjectStack.Common.Recipe.AbstractRecipe-1.html": {
    "href": "api/ProjectStack.Common.Recipe.AbstractRecipe-1.html",
    "title": "AbstractRecipe<TRecipeInput> Á±ª | ProjectStack",
    "keywords": "AbstractRecipe<TRecipeInput> Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public abstract class AbstractRecipe<TRecipeInput> Á±ªÂûãÂèÇÊï∞ TRecipeInput ÁªßÊâø object AbstractRecipe<TRecipeInput> ÊñπÊ≥ï Assmble(TRecipeInput, JsonObject) public abstract RecipeOutput Assmble(TRecipeInput recipeInput, JsonObject ntj) ÂèÇÊï∞ recipeInput TRecipeInput ntj JsonObject ËøîÂõû RecipeOutput Matchs(TRecipeInput, JsonObject) public abstract bool Matchs(TRecipeInput recipeInput, JsonObject ntj) ÂèÇÊï∞ recipeInput TRecipeInput ntj JsonObject ËøîÂõû bool Type() public abstract ResourceLocation Type() ËøîÂõû ResourceLocation"
  },
  "api/ProjectStack.Common.Recipe.CardMetaMatchRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.CardMetaMatchRecipe.html",
    "title": "CardMetaMatchRecipe Á±ª | ProjectStack",
    "keywords": "CardMetaMatchRecipe Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public class CardMetaMatchRecipe : IRecipe ÁªßÊâø object CardMetaMatchRecipe ÂÆûÁé∞ IRecipe ÊûÑÈÄ†ÂáΩÊï∞ CardMetaMatchRecipe(IList<CardMeta>, IList<CardMeta>, bool) public CardMetaMatchRecipe(IList<CardMeta> requiredCardMetas, IList<CardMeta> producedCardMetas, bool isNeedOrder = false) ÂèÇÊï∞ requiredCardMetas IList<CardMeta> producedCardMetas IList<CardMeta> isNeedOrder bool Â±ûÊÄß CardViewCount ÈÖçÊñπÈúÄË¶ÅÊ£ÄÊü•ÁöÑÂç°ÁâåÊï∞Èáè„ÄÇ‰∏∫nullÊó∂Ë°®Á§∫‰∏çÁ°ÆÂÆö„ÄÇ public uint? CardViewCount { get; } Â±ûÊÄßÂÄº uint? IsNeedOrder public bool IsNeedOrder { get; set; } Â±ûÊÄßÂÄº bool ProducedCardMetas public IList<CardMeta> ProducedCardMetas { get; set; } Â±ûÊÄßÂÄº IList<CardMeta> RequiredCardMetas public IList<CardMeta> RequiredCardMetas { get; set; } Â±ûÊÄßÂÄº IList<CardMeta> ÊñπÊ≥ï Execute(ICardStack) ËÆ°ÁÆóÈÖçÊñπÁªìÊûú„ÄÇ public RecipeResult Execute(ICardStack cardStack) ÂèÇÊï∞ cardStack ICardStack ÈúÄË¶ÅËøõË°åËÆ°ÁÆóÁöÑÂç°Â†Ü ËøîÂõû RecipeResult ÈÖçÊñπËæìÂá∫"
  },
  "api/ProjectStack.Common.Recipe.IRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.IRecipe.html",
    "title": "IRecipe Êé•Âè£ | ProjectStack",
    "keywords": "IRecipe Êé•Âè£ ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public interface IRecipe Â±ûÊÄß CardViewCount ÈÖçÊñπÈúÄË¶ÅÊ£ÄÊü•ÁöÑÂç°ÁâåÊï∞Èáè„ÄÇ‰∏∫nullÊó∂Ë°®Á§∫‰∏çÁ°ÆÂÆö„ÄÇ uint? CardViewCount { get; } Â±ûÊÄßÂÄº uint? ÊñπÊ≥ï Execute(ICardStack) ËÆ°ÁÆóÈÖçÊñπÁªìÊûú„ÄÇ RecipeResult Execute(ICardStack cardStack) ÂèÇÊï∞ cardStack ICardStack ÈúÄË¶ÅËøõË°åËÆ°ÁÆóÁöÑÂç°Â†Ü ËøîÂõû RecipeResult ÈÖçÊñπËæìÂá∫"
  },
  "api/ProjectStack.Common.Recipe.IRecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.IRecipeInput.html",
    "title": "IRecipeInput Êé•Âè£ | ProjectStack",
    "keywords": "IRecipeInput Êé•Âè£ ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public interface IRecipeInput"
  },
  "api/ProjectStack.Common.Recipe.RecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeInput.html",
    "title": "RecipeInput Á±ª | ProjectStack",
    "keywords": "RecipeInput Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public abstract record RecipeInput ÁªßÊâø object RecipeInput Derived ScriptRecipeInput ÊñπÊ≥ï Assemble(Card) public abstract Card Assemble(Card card) ÂèÇÊï∞ card Card ËøîÂõû Card IsMatch(Card) public abstract bool IsMatch(Card card) ÂèÇÊï∞ card Card ËøîÂõû bool"
  },
  "api/ProjectStack.Common.Recipe.RecipeOutput.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeOutput.html",
    "title": "RecipeOutput Á±ª | ProjectStack",
    "keywords": "RecipeOutput Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public record RecipeOutput ÁªßÊâø object RecipeOutput ÊûÑÈÄ†ÂáΩÊï∞ RecipeOutput(List<Card>, JsonObject) public RecipeOutput(List<Card> Cards, JsonObject Ntj) ÂèÇÊï∞ Cards List<Card> Ntj JsonObject Â±ûÊÄß Cards public List<Card> Cards { get; init; } Â±ûÊÄßÂÄº List<Card> Ntj public JsonObject Ntj { get; init; } Â±ûÊÄßÂÄº JsonObject"
  },
  "api/ProjectStack.Common.Recipe.RecipeRegistrationHelper.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeRegistrationHelper.html",
    "title": "RecipeRegistrationHelper Á±ª | ProjectStack",
    "keywords": "RecipeRegistrationHelper Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public class RecipeRegistrationHelper ÁªßÊâø object RecipeRegistrationHelper ÊûÑÈÄ†ÂáΩÊï∞ RecipeRegistrationHelper(IServiceCollection) public RecipeRegistrationHelper(IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ÊñπÊ≥ï Add(IRecipe) public RecipeRegistrationHelper Add(IRecipe recipe) ÂèÇÊï∞ recipe IRecipe ËøîÂõû RecipeRegistrationHelper End() public IServiceCollection End() ËøîÂõû IServiceCollection"
  },
  "api/ProjectStack.Common.Recipe.RecipeResult.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeResult.html",
    "title": "RecipeResult Á±ª | ProjectStack",
    "keywords": "RecipeResult Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public record RecipeResult ÁªßÊâø object RecipeResult ÊûÑÈÄ†ÂáΩÊï∞ RecipeResult(bool, IEnumerable<Card>, IEnumerable<Card>) public RecipeResult(bool IsMatch, IEnumerable<Card> ConsumedCards, IEnumerable<Card> ProducedCards) ÂèÇÊï∞ IsMatch bool ConsumedCards IEnumerable<Card> ProducedCards IEnumerable<Card> Â±ûÊÄß ConsumedCards public IEnumerable<Card> ConsumedCards { get; init; } Â±ûÊÄßÂÄº IEnumerable<Card> IsMatch public bool IsMatch { get; init; } Â±ûÊÄßÂÄº bool ProducedCards public IEnumerable<Card> ProducedCards { get; init; } Â±ûÊÄßÂÄº IEnumerable<Card>"
  },
  "api/ProjectStack.Common.Recipe.ScriptRecipeInput.ScriptContext.html": {
    "href": "api/ProjectStack.Common.Recipe.ScriptRecipeInput.ScriptContext.html",
    "title": "ScriptRecipeInput.ScriptContext Á±ª | ProjectStack",
    "keywords": "ScriptRecipeInput.ScriptContext Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public class ScriptRecipeInput.ScriptContext ÁªßÊâø object ScriptRecipeInput.ScriptContext Â≠óÊÆµ card public Card card Â≠óÊÆµÂÄº Card"
  },
  "api/ProjectStack.Common.Recipe.ScriptRecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.ScriptRecipeInput.html",
    "title": "ScriptRecipeInput Á±ª | ProjectStack",
    "keywords": "ScriptRecipeInput Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public record ScriptRecipeInput : RecipeInput ÁªßÊâø object RecipeInput ScriptRecipeInput ÊûÑÈÄ†ÂáΩÊï∞ ScriptRecipeInput() public ScriptRecipeInput() Â±ûÊÄß AssembleScript public string AssembleScript { get; init; } Â±ûÊÄßÂÄº string AssembleScriptRunner public ScriptRunner<Card> AssembleScriptRunner { get; } Â±ûÊÄßÂÄº ScriptRunner<Card> MatchScript public string MatchScript { get; init; } Â±ûÊÄßÂÄº string MatchScriptRunner public ScriptRunner<bool> MatchScriptRunner { get; } Â±ûÊÄßÂÄº ScriptRunner<bool> ÊñπÊ≥ï Assemble(Card) public override Card Assemble(Card card) ÂèÇÊï∞ card Card ËøîÂõû Card IsMatch(Card) public override bool IsMatch(Card card) ÂèÇÊï∞ card Card ËøîÂõû bool"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.Ingredient.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.Ingredient.html",
    "title": "SimpleRecipe.Ingredient Á±ª | ProjectStack",
    "keywords": "SimpleRecipe.Ingredient Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public record SimpleRecipe.Ingredient ÁªßÊâø object SimpleRecipe.Ingredient ÊûÑÈÄ†ÂáΩÊï∞ Ingredient(ResourceLocation, int, bool) public Ingredient(ResourceLocation CardId, int Quantity, bool Consumed) ÂèÇÊï∞ CardId ResourceLocation Quantity int Consumed bool Â±ûÊÄß CardId public ResourceLocation CardId { get; init; } Â±ûÊÄßÂÄº ResourceLocation Consumed public bool Consumed { get; init; } Â±ûÊÄßÂÄº bool Quantity public int Quantity { get; init; } Â±ûÊÄßÂÄº int"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.Product.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.Product.html",
    "title": "SimpleRecipe.Product Á±ª | ProjectStack",
    "keywords": "SimpleRecipe.Product Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll public record SimpleRecipe.Product ÁªßÊâø object SimpleRecipe.Product ÊûÑÈÄ†ÂáΩÊï∞ Product(ResourceLocation, int) public Product(ResourceLocation CardId, int Quantity) ÂèÇÊï∞ CardId ResourceLocation Quantity int Â±ûÊÄß CardId public ResourceLocation CardId { get; init; } Â±ûÊÄßÂÄº ResourceLocation Quantity public int Quantity { get; init; } Â±ûÊÄßÂÄº int"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.html",
    "title": "SimpleRecipe Á±ª | ProjectStack",
    "keywords": "SimpleRecipe Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common.Recipe Á®ãÂ∫èÈõÜ ProjectStack.dll Ë°®Á§∫ÈÖçÊñπÁöÑÊï∞ÊçÆÁªìÊûÑ public record SimpleRecipe ÁªßÊâø object SimpleRecipe ÊûÑÈÄ†ÂáΩÊï∞ SimpleRecipe(ResourceLocation, string, string, float, IImmutableList<Ingredient>, IImmutableList<Product>) Ë°®Á§∫ÈÖçÊñπÁöÑÊï∞ÊçÆÁªìÊûÑ public SimpleRecipe(ResourceLocation Id, string Name, string Description, float Production, IImmutableList<SimpleRecipe.Ingredient> Ingredients, IImmutableList<SimpleRecipe.Product> Products) ÂèÇÊï∞ Id ResourceLocation ÈÖçÊñπÊ†áËØÜÁ¨¶ Name string Description string Production float Áîü‰∫ßÂäõÊ∂àËÄó Ingredients IImmutableList<SimpleRecipe.Ingredient> ÂéüÊñô Products IImmutableList<SimpleRecipe.Product> ‰∫ßÂìÅ Â±ûÊÄß Description public string Description { get; init; } Â±ûÊÄßÂÄº string Id ÈÖçÊñπÊ†áËØÜÁ¨¶ public ResourceLocation Id { get; init; } Â±ûÊÄßÂÄº ResourceLocation Ingredients ÂéüÊñô public IImmutableList<SimpleRecipe.Ingredient> Ingredients { get; init; } Â±ûÊÄßÂÄº IImmutableList<SimpleRecipe.Ingredient> Name public string Name { get; init; } Â±ûÊÄßÂÄº string Production Áîü‰∫ßÂäõÊ∂àËÄó public float Production { get; init; } Â±ûÊÄßÂÄº float Products ‰∫ßÂìÅ public IImmutableList<SimpleRecipe.Product> Products { get; init; } Â±ûÊÄßÂÄº IImmutableList<SimpleRecipe.Product> ÊñπÊ≥ï SatisfactionCheck(IImmutableList<CardMeta>) public bool SatisfactionCheck(IImmutableList<CardMeta> cards) ÂèÇÊï∞ cards IImmutableList<CardMeta> ËøîÂõû bool"
  },
  "api/ProjectStack.Common.Recipe.html": {
    "href": "api/ProjectStack.Common.Recipe.html",
    "title": "ProjectStack.Common.Recipe ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Common.Recipe ÂëΩÂêçÁ©∫Èó¥ Á±ª AbstractRecipe<TRecipeInput> CardMetaMatchRecipe RecipeInput RecipeOutput RecipeRegistrationHelper RecipeResult ScriptRecipeInput ScriptRecipeInput.ScriptContext SimpleRecipe Ë°®Á§∫ÈÖçÊñπÁöÑÊï∞ÊçÆÁªìÊûÑ SimpleRecipe.Ingredient SimpleRecipe.Product Êé•Âè£ IRecipe IRecipeInput"
  },
  "api/ProjectStack.Common.ResourceLocation.html": {
    "href": "api/ProjectStack.Common.ResourceLocation.html",
    "title": "ResourceLocation Á±ª | ProjectStack",
    "keywords": "ResourceLocation Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Common Á®ãÂ∫èÈõÜ ProjectStack.dll public record ResourceLocation ÁªßÊâø object ResourceLocation ÊûÑÈÄ†ÂáΩÊï∞ ResourceLocation(string, string) public ResourceLocation(string Namespace, string Path) ÂèÇÊï∞ Namespace string Path string Â±ûÊÄß EMPTY public static ResourceLocation EMPTY { get; } Â±ûÊÄßÂÄº ResourceLocation GetNamespace public string GetNamespace { get; } Â±ûÊÄßÂÄº string GetPath public string GetPath { get; } Â±ûÊÄßÂÄº string Namespace public string Namespace { get; init; } Â±ûÊÄßÂÄº string Path public string Path { get; init; } Â±ûÊÄßÂÄº string ÊñπÊ≥ï DefaultNamespaceAndPath(string) public static ResourceLocation DefaultNamespaceAndPath(string path) ÂèÇÊï∞ path string ËøîÂõû ResourceLocation FromNamespaceAndPath(string, string) public static ResourceLocation FromNamespaceAndPath(string @namespace, string path) ÂèÇÊï∞ namespace string path string ËøîÂõû ResourceLocation GetResLoc() public string GetResLoc() ËøîÂõû string GetResLocWithPath(string) public string GetResLocWithPath(string p) ÂèÇÊï∞ p string ËøîÂõû string GetResLocWithoutPrefix(string) public string GetResLocWithoutPrefix(string p) ÂèÇÊï∞ p string ËøîÂõû string Parse(string) public static ResourceLocation Parse(string fullPath) ÂèÇÊï∞ fullPath string ËøîÂõû ResourceLocation ToString() Returns a string that represents the current object. public override string ToString() ËøîÂõû string A string that represents the current object."
  },
  "api/ProjectStack.Common.html": {
    "href": "api/ProjectStack.Common.html",
    "title": "ProjectStack.Common ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Common ÂëΩÂêçÁ©∫Èó¥ Á±ª ResourceLocation"
  },
  "api/ProjectStack.Component.Card.TaskNotifier-1.html": {
    "href": "api/ProjectStack.Component.Card.TaskNotifier-1.html",
    "title": "Card.TaskNotifier<T> Á±ª | ProjectStack",
    "keywords": "Card.TaskNotifier<T> Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll A wrapping class that can hold a Task<TResult> value. protected sealed class Card.TaskNotifier<T> Á±ªÂûãÂèÇÊï∞ T The type of value for the wrapped Task<TResult> instance. ÁªßÊâø object Card.TaskNotifier<T> ËøêÁÆóÁ¨¶ implicit operator Task<T>?(TaskNotifier<T>?) Unwraps the Task<TResult> value stored in the current instance. public static implicit operator Task<T>?(Card.TaskNotifier<T>? notifier) ÂèÇÊï∞ notifier Card.TaskNotifier<T> The input Card.TaskNotifier<T> instance. ËøîÂõû Task<T>"
  },
  "api/ProjectStack.Component.Card.TaskNotifier.html": {
    "href": "api/ProjectStack.Component.Card.TaskNotifier.html",
    "title": "Card.TaskNotifier Á±ª | ProjectStack",
    "keywords": "Card.TaskNotifier Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll A wrapping class that can hold a Task value. protected sealed class Card.TaskNotifier ÁªßÊâø object Card.TaskNotifier ËøêÁÆóÁ¨¶ implicit operator Task?(TaskNotifier?) Unwraps the Task value stored in the current instance. public static implicit operator Task?(Card.TaskNotifier? notifier) ÂèÇÊï∞ notifier Card.TaskNotifier The input Card.TaskNotifier<T> instance. ËøîÂõû Task"
  },
  "api/ProjectStack.Component.Card.html": {
    "href": "api/ProjectStack.Component.Card.html",
    "title": "Card Á±ª | ProjectStack",
    "keywords": "Card Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. [ObservableObject] [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Component/Card.cs\")] public class Card : Node2D, INtjObject ÁªßÊâø object GodotObject Node CanvasItem Node2D Card ÂÆûÁé∞ INtjObject ÊûÑÈÄ†ÂáΩÊï∞ Card() public Card() Â≠óÊÆµ ForceMotion public bool ForceMotion Â≠óÊÆµÂÄº bool InMoveing public bool InMoveing Â≠óÊÆµÂÄº bool Â±ûÊÄß BottomCard public Card? BottomCard { get; set; } Â±ûÊÄßÂÄº Card BottomCards public IImmutableList<Card> BottomCards { get; } Â±ûÊÄßÂÄº IImmutableList<Card> CardMeta public CardMeta CardMeta { get; set; } Â±ûÊÄßÂÄº CardMeta CardNameLabel public Label? CardNameLabel { get; } Â±ûÊÄßÂÄº Label CardStack public ICardStack CardStack { get; } Â±ûÊÄßÂÄº ICardStack CharacterBody public CharacterBody2D? CharacterBody { get; } Â±ûÊÄßÂÄº CharacterBody2D CurrentStack public IImmutableList<Card> CurrentStack { get; } Â±ûÊÄßÂÄº IImmutableList<Card> IsRoot public bool IsRoot { get; } Â±ûÊÄßÂÄº bool IsUppest public bool IsUppest { get; } Â±ûÊÄßÂÄº bool Metatype Generated metatype information. public IMetatype Metatype { get; } Â±ûÊÄßÂÄº IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } Â±ûÊÄßÂÄº MixinBlackboard Ntj public JsonObject Ntj { get; set; } Â±ûÊÄßÂÄº JsonObject OnDrag public bool OnDrag { get; set; } Â±ûÊÄßÂÄº bool Panel public Control? Panel { get; } Â±ûÊÄßÂÄº Control RootCard public Card RootCard { get; } Â±ûÊÄßÂÄº Card TargetPosition public Vector2 TargetPosition { get; set; } Â±ûÊÄßÂÄº Vector2 TextureRect public TextureRect? TextureRect { get; } Â±ûÊÄßÂÄº TextureRect TopCard public Card? TopCard { get; set; } Â±ûÊÄßÂÄº Card TopCards public IImmutableList<Card> TopCards { get; } Â±ûÊÄßÂÄº IImmutableList<Card> UppestCard public Card UppestCard { get; } Â±ûÊÄßÂÄº Card ÊñπÊ≥ï GetGodotClassPropertyValue(in godot_string_name, out godot_variant) Get the value of a property contained in this class. This method is used by Godot to retrieve property values. Do not call or override this method. protected override bool GetGodotClassPropertyValue(in godot_string_name name, out godot_variant value) ÂèÇÊï∞ name godot_string_name Name of the property to get. value godot_variant Value of the property if it was found. ËøîÂõû bool true if a property with the given name was found. GetNearestSameCard(Card) public Card? GetNearestSameCard(Card card) ÂèÇÊï∞ card Card ËøîÂõû Card HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool OnCardAreaEntered(Area2D) public void OnCardAreaEntered(Area2D body) ÂèÇÊï∞ body Area2D OnCardAreaExited(Area2D) public void OnCardAreaExited(Area2D body) ÂèÇÊï∞ body Area2D OnCardStackChanged() Ëß¶ÂèëCardStackChanged‰∫ã‰ª∂„ÄÇ protected virtual void OnCardStackChanged() OnPropertyChanged(PropertyChangedEventArgs) Raises the PropertyChanged event. protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) ÂèÇÊï∞ e PropertyChangedEventArgs The input PropertyChangedEventArgs instance. OnPropertyChanged(string?) Raises the PropertyChanged event. protected void OnPropertyChanged(string? propertyName = null) ÂèÇÊï∞ propertyName string (optional) The name of the property that changed. OnPropertyChanging(PropertyChangingEventArgs) Raises the PropertyChanging event. protected virtual void OnPropertyChanging(PropertyChangingEventArgs e) ÂèÇÊï∞ e PropertyChangingEventArgs The input PropertyChangingEventArgs instance. OnPropertyChanging(string?) Raises the PropertyChanging event. protected void OnPropertyChanging(string? propertyName = null) ÂèÇÊï∞ propertyName string (optional) The name of the property that changed. OnReady() Notification received when the node is ready. public void OnReady() RefreshTexture() public void RefreshTexture() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data. SetGodotClassPropertyValue(in godot_string_name, in godot_variant) Set the value of a property contained in this class. This method is used by Godot to assign property values. Do not call or override this method. protected override bool SetGodotClassPropertyValue(in godot_string_name name, in godot_variant value) ÂèÇÊï∞ name godot_string_name Name of the property to set. value godot_variant Value to set the property to if it was found. ËøîÂõû bool true if a property with the given name was found. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, Action<Task?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion(ref Card.TaskNotifier? taskNotifier, Task? newValue, Action<Task?> callback, string? propertyName = null) ÂèÇÊï∞ taskNotifier Card.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. callback Action<Task> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the Card.TaskNotifier type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The Card.TaskNotifier type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier myTask; public Task MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion(ref Card.TaskNotifier? taskNotifier, Task? newValue, string? propertyName = null) ÂèÇÊï∞ taskNotifier Card.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task instance passed as argument is in any particular state. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, Action<Task<T>?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion<T>(ref Card.TaskNotifier<T>? taskNotifier, Task<T>? newValue, Action<Task<T>?> callback, string? propertyName = null) ÂèÇÊï∞ taskNotifier Card.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. callback Action<Task<T>> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of result for the Task<TResult> to set and monitor. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the Card.TaskNotifier<T> type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The Card.TaskNotifier<T> type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier<int> myTask; public Task<int> MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion<T>(ref Card.TaskNotifier<T>? taskNotifier, Task<T>? newValue, string? propertyName = null) ÂèÇÊï∞ taskNotifier Card.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of result for the Task<TResult> to set and monitor. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task<TResult> instance passed as argument is in any particular state. SetProperty<T>(T, T, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. This overload is much less efficient than SetProperty<T>(ref T, T, string?) and it should only be used when the former is not viable (eg. when the target property being updated does not directly expose a backing field that can be passed by reference). For performance reasons, it is recommended to use a stateful callback if possible through the SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) whenever possible instead of this overload, as that will allow the C# compiler to cache the input callback and reduce the memory allocations. More info on that overload are available in the related XML docs. This overload is here for completeness and in cases where that is not applicable. protected bool SetProperty<T>(T oldValue, T newValue, Action<T> callback, string? propertyName = null) ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<T>(T, T, IEqualityComparer<T>, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(T, T, Action<T>, string?). protected bool SetProperty<T>(T oldValue, T newValue, IEqualityComparer<T> comparer, Action<T> callback, string? propertyName = null) ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. SetProperty<T>(ref T, T, IEqualityComparer<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(ref T, T, string?). protected bool SetProperty<T>(ref T field, T newValue, IEqualityComparer<T> comparer, string? propertyName = null) ÂèÇÊï∞ field T The field storing the property's value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. SetProperty<T>(ref T, T, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. protected bool SetProperty<T>(ref T field, T newValue, string? propertyName = null) ÂèÇÊï∞ field T The field storing the property's value. newValue T The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<TModel, T>(T, T, IEqualityComparer<T>, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. See additional notes about this overload in SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?). protected bool SetProperty<TModel, T>(T oldValue, T newValue, IEqualityComparer<T> comparer, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ TModel The type of model whose property (or field) to set. T The type of property (or field) to set. SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. This type is useful when creating wrapping, bindable objects that operate over models that lack support for notification (eg. for CRUD operations). Suppose we have this model (eg. for a database row in a table): public class Person { public string Name { get; set; } } We can then use a property to wrap instances of this type into our observable model (which supports notifications), injecting the notification to the properties of that model, like so: [ObservableObject] public class BindablePerson { public Model { get; } public BindablePerson(Person model) { Model = model; } public string Name { get => Model.Name; set => Set(Model.Name, value, Model, (model, name) => model.Name = name); } } This way we can then use the wrapping object in our application, and all those \"proxy\" properties will also raise notifications when changed. Note that this method is not meant to be a replacement for SetProperty<T>(ref T, T, string?), and it should only be used when relaying properties to a model that doesn't support notifications, and only if you can't implement notifications to that model directly (eg. by having it inherit from ObservableObject). The syntax relies on passing the target model and a stateless callback to allow the C# compiler to cache the function, which results in much better performance and no memory usage. protected bool SetProperty<TModel, T>(T oldValue, T newValue, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ TModel The type of model whose property (or field) to set. T The type of property (or field) to set. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. UpdateAllZIndex() public void UpdateAllZIndex() UpdateRecipe() public void UpdateRecipe() UpdateZIndex() public void UpdateZIndex() _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) ÂèÇÊï∞ what int _Process(double) Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the delta time since the previous frame is not constant. delta is in seconds. It is only called if processing is enabled, which is done automatically if this method is overridden, and can be toggled with SetProcess(bool). Corresponds to the Godot.Node.NotificationProcess notification in _Notification(int). Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan). public override void _Process(double delta) ÂèÇÊï∞ delta double _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready() ‰∫ã‰ª∂ CardStackChanged ÂΩìÂç°Â†ÜÂèëÁîüÂèòÂåñÊó∂Ëß¶Âèë„ÄÇ public event Action<ICardStack>? CardStackChanged ‰∫ã‰ª∂Á±ªÂûã Action<ICardStack> PropertyChanged Occurs when a property value changes. public event PropertyChangedEventHandler? PropertyChanged ‰∫ã‰ª∂Á±ªÂûã PropertyChangedEventHandler PropertyChanging Occurs when a property value is changing. public event PropertyChangingEventHandler? PropertyChanging ‰∫ã‰ª∂Á±ªÂûã PropertyChangingEventHandler"
  },
  "api/ProjectStack.Component.InfoTab.TaskNotifier-1.html": {
    "href": "api/ProjectStack.Component.InfoTab.TaskNotifier-1.html",
    "title": "InfoTab.TaskNotifier<T> Á±ª | ProjectStack",
    "keywords": "InfoTab.TaskNotifier<T> Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll A wrapping class that can hold a Task<TResult> value. protected sealed class InfoTab.TaskNotifier<T> Á±ªÂûãÂèÇÊï∞ T The type of value for the wrapped Task<TResult> instance. ÁªßÊâø object InfoTab.TaskNotifier<T> ËøêÁÆóÁ¨¶ implicit operator Task<T>?(TaskNotifier<T>?) Unwraps the Task<TResult> value stored in the current instance. public static implicit operator Task<T>?(InfoTab.TaskNotifier<T>? notifier) ÂèÇÊï∞ notifier InfoTab.TaskNotifier<T> The input InfoTab.TaskNotifier<T> instance. ËøîÂõû Task<T>"
  },
  "api/ProjectStack.Component.InfoTab.TaskNotifier.html": {
    "href": "api/ProjectStack.Component.InfoTab.TaskNotifier.html",
    "title": "InfoTab.TaskNotifier Á±ª | ProjectStack",
    "keywords": "InfoTab.TaskNotifier Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll A wrapping class that can hold a Task value. protected sealed class InfoTab.TaskNotifier ÁªßÊâø object InfoTab.TaskNotifier ËøêÁÆóÁ¨¶ implicit operator Task?(TaskNotifier?) Unwraps the Task value stored in the current instance. public static implicit operator Task?(InfoTab.TaskNotifier? notifier) ÂèÇÊï∞ notifier InfoTab.TaskNotifier The input InfoTab.TaskNotifier<T> instance. ËøîÂõû Task"
  },
  "api/ProjectStack.Component.InfoTab.html": {
    "href": "api/ProjectStack.Component.InfoTab.html",
    "title": "InfoTab Á±ª | ProjectStack",
    "keywords": "InfoTab Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Component Á®ãÂ∫èÈõÜ ProjectStack.dll Base class for all UI-related nodes. Godot.Control features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from Godot.Control and Godot.Container nodes. User Interface nodes and input Godot propagates input events via viewports. Each Godot.Viewport is responsible for propagating Godot.InputEvents to their child nodes. As the Godot.SceneTree.Root is a Godot.Window, this already happens automatically for all UI elements in your game. Input events are propagated through the Godot.SceneTree from the root node to all child nodes by calling Godot.Node._Input(Godot.InputEvent). For UI elements specifically, it makes more sense to override the virtual method Godot.Control._GuiInput(Godot.InputEvent), which filters out unrelated input events, such as by checking z-order, Godot.Control.MouseFilter, focus, or if the event was inside of the control's bounding box. Call Godot.Control.AcceptEvent() so no other node receives the event. Once you accept an input, it becomes handled so Godot.Node._UnhandledInput(Godot.InputEvent) will not process it. Only one Godot.Control node can be in focus. Only the node in focus will receive events. To get the focus, call Godot.Control.GrabFocus(). Godot.Control nodes lose focus when another node grabs it, or if you hide the node in focus. Sets Godot.Control.MouseFilter to Godot.Control.MouseFilterEnum.Ignore to tell a Godot.Control node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. Godot.Theme resources change the Control's appearance. If you change the Godot.Theme on a Godot.Control node, it affects all of its children. To override some of the theme's parameters, call one of the add_theme_*_override methods, like Godot.Control.AddThemeFontOverride(Godot.StringName, Godot.Font). You can override the theme with the Inspector. Note: Theme items are notGodot.GodotObject properties. This means you can't access their values using Godot.GodotObject.Get(Godot.StringName) and Godot.GodotObject.Set(Godot.StringName, Godot.Variant). Instead, use the get_theme_* and add_theme_*_override methods provided by this class. [ObservableObject] [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Component/InfoTab.cs\")] public class InfoTab : Control ÁªßÊâø object GodotObject Node CanvasItem Control InfoTab Â±ûÊÄß Metatype Generated metatype information. public IMetatype Metatype { get; } Â±ûÊÄßÂÄº IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } Â±ûÊÄßÂÄº MixinBlackboard ÊñπÊ≥ï GetGodotClassPropertyValue(in godot_string_name, out godot_variant) Get the value of a property contained in this class. This method is used by Godot to retrieve property values. Do not call or override this method. protected override bool GetGodotClassPropertyValue(in godot_string_name name, out godot_variant value) ÂèÇÊï∞ name godot_string_name Name of the property to get. value godot_variant Value of the property if it was found. ËøîÂõû bool true if a property with the given name was found. HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool OnProcess(double) Notification received from the tree every rendered frame when Godot.Node.IsPhysicsProcessing() returns true. public void OnProcess(double delta) ÂèÇÊï∞ delta double Time since the last process update, in seconds. OnPropertyChanged(PropertyChangedEventArgs) Raises the PropertyChanged event. protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) ÂèÇÊï∞ e PropertyChangedEventArgs The input PropertyChangedEventArgs instance. OnPropertyChanged(string?) Raises the PropertyChanged event. protected void OnPropertyChanged(string? propertyName = null) ÂèÇÊï∞ propertyName string (optional) The name of the property that changed. OnPropertyChanging(PropertyChangingEventArgs) Raises the PropertyChanging event. protected virtual void OnPropertyChanging(PropertyChangingEventArgs e) ÂèÇÊï∞ e PropertyChangingEventArgs The input PropertyChangingEventArgs instance. OnPropertyChanging(string?) Raises the PropertyChanging event. protected void OnPropertyChanging(string? propertyName = null) ÂèÇÊï∞ propertyName string (optional) The name of the property that changed. OnReady() Notification received when the node is ready. public void OnReady() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data. SetGodotClassPropertyValue(in godot_string_name, in godot_variant) Set the value of a property contained in this class. This method is used by Godot to assign property values. Do not call or override this method. protected override bool SetGodotClassPropertyValue(in godot_string_name name, in godot_variant value) ÂèÇÊï∞ name godot_string_name Name of the property to set. value godot_variant Value to set the property to if it was found. ËøîÂõû bool true if a property with the given name was found. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, Action<Task?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion(ref InfoTab.TaskNotifier? taskNotifier, Task? newValue, Action<Task?> callback, string? propertyName = null) ÂèÇÊï∞ taskNotifier InfoTab.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. callback Action<Task> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the InfoTab.TaskNotifier type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The InfoTab.TaskNotifier type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier myTask; public Task MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion(ref InfoTab.TaskNotifier? taskNotifier, Task? newValue, string? propertyName = null) ÂèÇÊï∞ taskNotifier InfoTab.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task instance passed as argument is in any particular state. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, Action<Task<T>?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion<T>(ref InfoTab.TaskNotifier<T>? taskNotifier, Task<T>? newValue, Action<Task<T>?> callback, string? propertyName = null) ÂèÇÊï∞ taskNotifier InfoTab.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. callback Action<Task<T>> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of result for the Task<TResult> to set and monitor. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the InfoTab.TaskNotifier<T> type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The InfoTab.TaskNotifier<T> type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier<int> myTask; public Task<int> MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion<T>(ref InfoTab.TaskNotifier<T>? taskNotifier, Task<T>? newValue, string? propertyName = null) ÂèÇÊï∞ taskNotifier InfoTab.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of result for the Task<TResult> to set and monitor. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task<TResult> instance passed as argument is in any particular state. SetProperty<T>(T, T, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. This overload is much less efficient than SetProperty<T>(ref T, T, string?) and it should only be used when the former is not viable (eg. when the target property being updated does not directly expose a backing field that can be passed by reference). For performance reasons, it is recommended to use a stateful callback if possible through the SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) whenever possible instead of this overload, as that will allow the C# compiler to cache the input callback and reduce the memory allocations. More info on that overload are available in the related XML docs. This overload is here for completeness and in cases where that is not applicable. protected bool SetProperty<T>(T oldValue, T newValue, Action<T> callback, string? propertyName = null) ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<T>(T, T, IEqualityComparer<T>, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(T, T, Action<T>, string?). protected bool SetProperty<T>(T oldValue, T newValue, IEqualityComparer<T> comparer, Action<T> callback, string? propertyName = null) ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. SetProperty<T>(ref T, T, IEqualityComparer<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(ref T, T, string?). protected bool SetProperty<T>(ref T field, T newValue, IEqualityComparer<T> comparer, string? propertyName = null) ÂèÇÊï∞ field T The field storing the property's value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. SetProperty<T>(ref T, T, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. protected bool SetProperty<T>(ref T field, T newValue, string? propertyName = null) ÂèÇÊï∞ field T The field storing the property's value. newValue T The property's value after the change occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ T The type of the property that changed. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<TModel, T>(T, T, IEqualityComparer<T>, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. See additional notes about this overload in SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?). protected bool SetProperty<TModel, T>(T oldValue, T newValue, IEqualityComparer<T> comparer, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ TModel The type of model whose property (or field) to set. T The type of property (or field) to set. SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. This type is useful when creating wrapping, bindable objects that operate over models that lack support for notification (eg. for CRUD operations). Suppose we have this model (eg. for a database row in a table): public class Person { public string Name { get; set; } } We can then use a property to wrap instances of this type into our observable model (which supports notifications), injecting the notification to the properties of that model, like so: [ObservableObject] public class BindablePerson { public Model { get; } public BindablePerson(Person model) { Model = model; } public string Name { get => Model.Name; set => Set(Model.Name, value, Model, (model, name) => model.Name = name); } } This way we can then use the wrapping object in our application, and all those \"proxy\" properties will also raise notifications when changed. Note that this method is not meant to be a replacement for SetProperty<T>(ref T, T, string?), and it should only be used when relaying properties to a model that doesn't support notifications, and only if you can't implement notifications to that model directly (eg. by having it inherit from ObservableObject). The syntax relies on passing the target model and a stateless callback to allow the C# compiler to cache the function, which results in much better performance and no memory usage. protected bool SetProperty<TModel, T>(T oldValue, T newValue, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class ÂèÇÊï∞ oldValue T The current property value. newValue T The property's value after the change occurred. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. ËøîÂõû bool true if the property was changed, false otherwise. Á±ªÂûãÂèÇÊï∞ TModel The type of model whose property (or field) to set. T The type of property (or field) to set. Â§áÊ≥® The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) ÂèÇÊï∞ what int ‰∫ã‰ª∂ PropertyChanged Occurs when a property value changes. public event PropertyChangedEventHandler? PropertyChanged ‰∫ã‰ª∂Á±ªÂûã PropertyChangedEventHandler PropertyChanging Occurs when a property value is changing. public event PropertyChangingEventHandler? PropertyChanging ‰∫ã‰ª∂Á±ªÂûã PropertyChangingEventHandler"
  },
  "api/ProjectStack.Component.html": {
    "href": "api/ProjectStack.Component.html",
    "title": "ProjectStack.Component ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Component ÂëΩÂêçÁ©∫Èó¥ Á±ª Card A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. Card.TaskNotifier A wrapping class that can hold a Task value. Card.TaskNotifier<T> A wrapping class that can hold a Task<TResult> value. InfoTab Base class for all UI-related nodes. Godot.Control features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from Godot.Control and Godot.Container nodes. User Interface nodes and input Godot propagates input events via viewports. Each Godot.Viewport is responsible for propagating Godot.InputEvents to their child nodes. As the Godot.SceneTree.Root is a Godot.Window, this already happens automatically for all UI elements in your game. Input events are propagated through the Godot.SceneTree from the root node to all child nodes by calling Godot.Node._Input(Godot.InputEvent). For UI elements specifically, it makes more sense to override the virtual method Godot.Control._GuiInput(Godot.InputEvent), which filters out unrelated input events, such as by checking z-order, Godot.Control.MouseFilter, focus, or if the event was inside of the control's bounding box. Call Godot.Control.AcceptEvent() so no other node receives the event. Once you accept an input, it becomes handled so Godot.Node._UnhandledInput(Godot.InputEvent) will not process it. Only one Godot.Control node can be in focus. Only the node in focus will receive events. To get the focus, call Godot.Control.GrabFocus(). Godot.Control nodes lose focus when another node grabs it, or if you hide the node in focus. Sets Godot.Control.MouseFilter to Godot.Control.MouseFilterEnum.Ignore to tell a Godot.Control node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. Godot.Theme resources change the Control's appearance. If you change the Godot.Theme on a Godot.Control node, it affects all of its children. To override some of the theme's parameters, call one of the add_theme_*_override methods, like Godot.Control.AddThemeFontOverride(Godot.StringName, Godot.Font). You can override the theme with the Inspector. Note: Theme items are notGodot.GodotObject properties. This means you can't access their values using Godot.GodotObject.Get(Godot.StringName) and Godot.GodotObject.Set(Godot.StringName, Godot.Variant). Instead, use the get_theme_* and add_theme_*_override methods provided by this class. InfoTab.TaskNotifier A wrapping class that can hold a Task value. InfoTab.TaskNotifier<T> A wrapping class that can hold a Task<TResult> value."
  },
  "api/ProjectStack.Core.CardMgr.html": {
    "href": "api/ProjectStack.Core.CardMgr.html",
    "title": "CardMgr Á±ª | ProjectStack",
    "keywords": "CardMgr Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Core Á®ãÂ∫èÈõÜ ProjectStack.dll [ScriptPath(\"res://src/scripts/Core/CardMgr.cs\")] public class CardMgr : Node ÁªßÊâø object GodotObject Node CardMgr ÊñπÊ≥ï RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data."
  },
  "api/ProjectStack.Core.ServiceCollectionExtension.html": {
    "href": "api/ProjectStack.Core.ServiceCollectionExtension.html",
    "title": "ServiceCollectionExtension Á±ª | ProjectStack",
    "keywords": "ServiceCollectionExtension Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Core Á®ãÂ∫èÈõÜ ProjectStack.dll public static class ServiceCollectionExtension ÁªßÊâø object ServiceCollectionExtension ÊñπÊ≥ï ConfigureHoveredItemInfoDisplay(IServiceCollection) public static HoveredItemInfoDisplayRegistrationHelper ConfigureHoveredItemInfoDisplay(this IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ËøîÂõû HoveredItemInfoDisplayRegistrationHelper RegisterCardMetas(IServiceCollection) public static CardMetaRegistrationHelper RegisterCardMetas(this IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ËøîÂõû CardMetaRegistrationHelper RegisterRecipes(IServiceCollection) public static RecipeRegistrationHelper RegisterRecipes(this IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ËøîÂõû RecipeRegistrationHelper RegisterTextureLoader(IServiceCollection) public static TextureLoader RegisterTextureLoader(this IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ËøîÂõû TextureLoader"
  },
  "api/ProjectStack.Core.html": {
    "href": "api/ProjectStack.Core.html",
    "title": "ProjectStack.Core ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Core ÂëΩÂêçÁ©∫Èó¥ Á±ª CardMgr ServiceCollectionExtension"
  },
  "api/ProjectStack.Game.html": {
    "href": "api/ProjectStack.Game.html",
    "title": "Game Á±ª | ProjectStack",
    "keywords": "Game Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack Á®ãÂ∫èÈõÜ ProjectStack.dll [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/Game.cs\")] public class Game : Node2D ÁªßÊâø object GodotObject Node CanvasItem Node2D Game Â±ûÊÄß Default public static Game Default { get; } Â±ûÊÄßÂÄº Game Metatype Generated metatype information. public IMetatype Metatype { get; } Â±ûÊÄßÂÄº IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } Â±ûÊÄßÂÄº MixinBlackboard Recipes public IImmutableList<IRecipe> Recipes { get; } Â±ûÊÄßÂÄº IImmutableList<IRecipe> ServiceProvider public IServiceProvider ServiceProvider { get; } Â±ûÊÄßÂÄº IServiceProvider ÊñπÊ≥ï HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool OnReady() Notification received when the node is ready. public void OnReady() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data. Value() Value that is provided by the provider. public IServiceProvider Value() ËøîÂõû IServiceProvider _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) ÂèÇÊï∞ what int"
  },
  "api/ProjectStack.Launcher.html": {
    "href": "api/ProjectStack.Launcher.html",
    "title": "Launcher Á±ª | ProjectStack",
    "keywords": "Launcher Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack Á®ãÂ∫èÈõÜ ProjectStack.dll [ScriptPath(\"res://src/Launcher.cs\")] public class Launcher : Node ÁªßÊâø object GodotObject Node Launcher ÊñπÊ≥ï HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data. _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready()"
  },
  "api/ProjectStack.Main.html": {
    "href": "api/ProjectStack.Main.html",
    "title": "Main Á±ª | ProjectStack",
    "keywords": "Main Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack Á®ãÂ∫èÈõÜ ProjectStack.dll [ScriptPath(\"res://src/Main.cs\")] public class Main : Node2D ÁªßÊâø object GodotObject Node CanvasItem Node2D Main ÊñπÊ≥ï HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) ÂèÇÊï∞ method godot_string_name Name of the method to check for. ËøîÂõû bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) ÂèÇÊï∞ method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. ËøîÂõû bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) ÂèÇÊï∞ info GodotSerializationInfo Object used to save the data. _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready()"
  },
  "api/ProjectStack.NamedTagsBaseOnJson.INtjObject.html": {
    "href": "api/ProjectStack.NamedTagsBaseOnJson.INtjObject.html",
    "title": "INtjObject Êé•Âè£ | ProjectStack",
    "keywords": "INtjObject Êé•Âè£ ÂëΩÂêçÁ©∫Èó¥ ProjectStack.NamedTagsBaseOnJson Á®ãÂ∫èÈõÜ ProjectStack.dll public interface INtjObject Â±ûÊÄß Ntj JsonObject Ntj { get; } Â±ûÊÄßÂÄº JsonObject"
  },
  "api/ProjectStack.NamedTagsBaseOnJson.html": {
    "href": "api/ProjectStack.NamedTagsBaseOnJson.html",
    "title": "ProjectStack.NamedTagsBaseOnJson ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.NamedTagsBaseOnJson ÂëΩÂêçÁ©∫Èó¥ Êé•Âè£ INtjObject"
  },
  "api/ProjectStack.Resource.TextureLoader.html": {
    "href": "api/ProjectStack.Resource.TextureLoader.html",
    "title": "TextureLoader Á±ª | ProjectStack",
    "keywords": "TextureLoader Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Resource Á®ãÂ∫èÈõÜ ProjectStack.dll public class TextureLoader ÁªßÊâø object TextureLoader ÊûÑÈÄ†ÂáΩÊï∞ TextureLoader(IServiceCollection) public TextureLoader(IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ÊñπÊ≥ï AddTextureDirectory(string) public TextureLoader AddTextureDirectory(string directoryPath) ÂèÇÊï∞ directoryPath string ËøîÂõû TextureLoader End() public IServiceCollection End() ËøîÂõû IServiceCollection"
  },
  "api/ProjectStack.Resource.html": {
    "href": "api/ProjectStack.Resource.html",
    "title": "ProjectStack.Resource ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Resource ÂëΩÂêçÁ©∫Èó¥ Á±ª TextureLoader"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoDisplay.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoDisplay.html",
    "title": "HoveredItemInfoDisplay Á±ª | ProjectStack",
    "keywords": "HoveredItemInfoDisplay Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.UserInterface Á®ãÂ∫èÈõÜ ProjectStack.dll public class HoveredItemInfoDisplay ÁªßÊâø object HoveredItemInfoDisplay ÊûÑÈÄ†ÂáΩÊï∞ HoveredItemInfoDisplay(IServiceCollection) public HoveredItemInfoDisplay(IServiceCollection services) ÂèÇÊï∞ services IServiceCollection Â±ûÊÄß HoveredItemInfoProviders public List<HoveredItemInfoProvider> HoveredItemInfoProviders { get; } Â±ûÊÄßÂÄº List<HoveredItemInfoProvider> HoveredItemInfoTexts public IImmutableList<string> HoveredItemInfoTexts { get; } Â±ûÊÄßÂÄº IImmutableList<string> HoveredItems public ObservableCollection<Node> HoveredItems { get; } Â±ûÊÄßÂÄº ObservableCollection<Node>"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoDisplayRegistrationHelper.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoDisplayRegistrationHelper.html",
    "title": "HoveredItemInfoDisplayRegistrationHelper Á±ª | ProjectStack",
    "keywords": "HoveredItemInfoDisplayRegistrationHelper Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.UserInterface Á®ãÂ∫èÈõÜ ProjectStack.dll public class HoveredItemInfoDisplayRegistrationHelper ÁªßÊâø object HoveredItemInfoDisplayRegistrationHelper ÊûÑÈÄ†ÂáΩÊï∞ HoveredItemInfoDisplayRegistrationHelper(IServiceCollection) public HoveredItemInfoDisplayRegistrationHelper(IServiceCollection services) ÂèÇÊï∞ services IServiceCollection ÊñπÊ≥ï End() public IServiceCollection End() ËøîÂõû IServiceCollection RegisterHoveredItemInfoProvider(HoveredItemInfoProvider) public HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(HoveredItemInfoProvider hoveredItemInfoProvider) ÂèÇÊï∞ hoveredItemInfoProvider HoveredItemInfoProvider ËøîÂõû HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(string, Predicate<HoveredItemInfoDisplay>, Func<HoveredItemInfoDisplay, string>) public HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(string providerName, Predicate<HoveredItemInfoDisplay> predicate, Func<HoveredItemInfoDisplay, string> displayTextProvider) ÂèÇÊï∞ providerName string predicate Predicate<HoveredItemInfoDisplay> displayTextProvider Func<HoveredItemInfoDisplay, string> ËøîÂõû HoveredItemInfoDisplayRegistrationHelper"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoProvider.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoProvider.html",
    "title": "HoveredItemInfoProvider Á±ª | ProjectStack",
    "keywords": "HoveredItemInfoProvider Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.UserInterface Á®ãÂ∫èÈõÜ ProjectStack.dll public class HoveredItemInfoProvider ÁªßÊâø object HoveredItemInfoProvider ÊûÑÈÄ†ÂáΩÊï∞ HoveredItemInfoProvider(string, Predicate<HoveredItemInfoDisplay>, Func<HoveredItemInfoDisplay, string>) public HoveredItemInfoProvider(string providerName, Predicate<HoveredItemInfoDisplay> predicate, Func<HoveredItemInfoDisplay, string> displayTextProvider) ÂèÇÊï∞ providerName string predicate Predicate<HoveredItemInfoDisplay> displayTextProvider Func<HoveredItemInfoDisplay, string> Â±ûÊÄß ProviderName public string ProviderName { get; } Â±ûÊÄßÂÄº string ÊñπÊ≥ï ProvideHoveredItemInfo(HoveredItemInfoDisplay) public string? ProvideHoveredItemInfo(HoveredItemInfoDisplay hoveredItemInfoDisplay) ÂèÇÊï∞ hoveredItemInfoDisplay HoveredItemInfoDisplay ËøîÂõû string"
  },
  "api/ProjectStack.UserInterface.html": {
    "href": "api/ProjectStack.UserInterface.html",
    "title": "ProjectStack.UserInterface ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.UserInterface ÂëΩÂêçÁ©∫Èó¥ Á±ª HoveredItemInfoDisplay HoveredItemInfoDisplayRegistrationHelper HoveredItemInfoProvider"
  },
  "api/ProjectStack.Util.FileSystemHelper.html": {
    "href": "api/ProjectStack.Util.FileSystemHelper.html",
    "title": "FileSystemHelper Á±ª | ProjectStack",
    "keywords": "FileSystemHelper Á±ª ÂëΩÂêçÁ©∫Èó¥ ProjectStack.Util Á®ãÂ∫èÈõÜ ProjectStack.dll public class FileSystemHelper ÁªßÊâø object FileSystemHelper Â±ûÊÄß Default public static FileSystemHelper Default { get; } Â±ûÊÄßÂÄº FileSystemHelper ÊñπÊ≥ï GetAllFilesInDirectory(string) public IEnumerable<string> GetAllFilesInDirectory(string directoryPath) ÂèÇÊï∞ directoryPath string ËøîÂõû IEnumerable<string>"
  },
  "api/ProjectStack.Util.html": {
    "href": "api/ProjectStack.Util.html",
    "title": "ProjectStack.Util ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack.Util ÂëΩÂêçÁ©∫Èó¥ Á±ª FileSystemHelper"
  },
  "api/ProjectStack.html": {
    "href": "api/ProjectStack.html",
    "title": "ProjectStack ÂëΩÂêçÁ©∫Èó¥ | ProjectStack",
    "keywords": "ProjectStack ÂëΩÂêçÁ©∫Èó¥ Á±ª CardTest Game Launcher Main"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | ProjectStack",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | ProjectStack",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | ProjectStack",
    "keywords": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}