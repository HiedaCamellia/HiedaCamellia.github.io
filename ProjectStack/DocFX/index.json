{
  "CONTRIBUTING.html": {
    "href": "CONTRIBUTING.html",
    "title": "Contributing | ProjectStack",
    "keywords": "Contributing Thank you for taking the time to read this contributing guide and for showing interest in helping this project! Getting Started Need a helping hand to get started? Check out these resources! Discord Server Chickensoft Website Please read our code of conduct. We do our best to treat others fairly and foster a welcoming environment. Project Setup This is a C# nuget package, for use with the .NET SDK 6 or 7. As such, the dotnet tool will allow you to restore packages and build projects. Coding Guidelines Your IDE should automatically adhere to the style guidelines in the provided .editorconfig file. Please try to keep lines under 80 characters long whenever possible. We try to write tests for our projects to ensure a certain level of quality. We are willing to give you support and guidance if you need help! Code of Conduct We follow the Contributor Covenant. In short: We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation."
  },
  "README.html": {
    "href": "README.html",
    "title": "ProjectStack | ProjectStack",
    "keywords": "ProjectStack C# game template for Godot 4 with debug launch configurations, testing (locally and on CI/CD), code coverage, dependency update checks, and spell check working out-of-the-box! ğŸ¥š Getting Started This template allows you to easily create a C# game for Godot 4. Microsoft's dotnet tool allows you to easily create, install, and use templates. # Install this template dotnet new install ProjectStack # Generate a new project based on this template dotnet new chickengame --name \"MyGameName\" --param:author \"My Name\" cd MyGameName dotnet build ğŸ’ Getting Help Is this template broken? Encountering obscure C# build problems? We'll be happy to help you in the Chickensoft Discord server. ğŸ Environment Setup For the provided debug configurations and test coverage to work correctly, you must setup your development environment correctly. The Chickensoft Setup Docs describe how to setup your Godot and C# development environment, using Chickensoft's best practice recommendations. VSCode Settings This template includes some Visual Studio Code settings in .vscode/settings.json. The settings facilitate terminal environments on Windows (Git Bash, PowerShell, Command Prompt) and macOS (zsh), as well as fixing some syntax colorization issues that Omnisharp suffers from. You'll also find settings that enable editor config support in Omnisharp and the .NET Roslyn analyzers for a more enjoyable coding experience. Please double-check that the provided VSCode settings don't conflict with your existing settings. .NET Versioning The included global.json specifies the version of the .NET SDK and Godot.NET.Sdk that the game should use. Using a global.json file allows Renovatebot to provide your repository with automatic dependency update pull requests whenever a new version of GodotSharp is released. ğŸ‘· Testing An example test is included in test/src/GameTest.cs that demonstrates how to write a test for your package using GoDotTest and godot-test-driver. GoDotTest is an easy-to-use testing framework for Godot and C# that allows you to run tests from the command line, collect code coverage, and debug tests in VSCode. Tests run directly inside the game. The .csproj file is already pre-configured to prevent test scripts and test-only package dependencies from being included in release builds of your game! On CI/CD, software graphics drivers from [mesa] emulate a virtual graphics device for Godot to render to, allowing you to run visual tests in a headless environment. ğŸ Application Entry Point The Main.tscn and Main.cs scene and script file are the entry point of your game. In general, you probably won't need to modify these unless you're doing something highly custom. If the game is running a release build, the Main.cs file will just immediately change the scene to src/Game.tscn. If the game is running in debug mode and GoDotTest has received the correct command line arguments to begin testing, the game will switch to the testing scene and hand off control to GoDotTest to run the game's tests. In general, prefer editing src/Game.tscn over src/Main.tscn. The provided debug configurations in .vscode/launch.json allow you to easily debug tests (or just the currently open test, provided its filename matches its class name). ğŸš¦ Test Coverage Code coverage requires a few dotnet global tools to be installed first. You should install these tools from the root of the project directory. The nuget.config file in the root of the project allows the correct version of coverlet to be installed from the coverlet nightly distributions. Overriding the coverlet version will be required until coverlet releases a stable version with the fixes that allow it to work with Godot 4. dotnet tool install --global coverlet.console dotnet tool update --global coverlet.console dotnet tool install --global dotnet-reportgenerator-globaltool dotnet tool update --global dotnet-reportgenerator-globaltool Running dotnet tool update for the global tool is often necessary on Apple Silicon computers to ensure the tools are installed correctly. You can collect code coverage and generate coverage badges by running the bash script coverage.sh (on Windows, you can use the Git Bash shell that comes with git). # Must give coverage script permission to run the first time it is used. chmod +x ./coverage.sh # Run code coverage: ./coverage.sh You can also run test coverage through VSCode by opening the command palette and selecting Tasks: Run Task and then choosing coverage. If you are having trouble with coverlet finding your .NET runtime on Windows, you can use the PowerShell Script coverage.ps1 instead. .\\coverage.ps1 â¯ Running the Project Several launch profiles are included for Visual Studio Code: ğŸ•¹ Debug Game Runs the game in debug mode, allowing you to set breakpoints and inspect variables. ğŸ­ Debug Current Scene Debugs the game and loads the scene with the same name and in the same path as the C# file that's actively selected in VSCode: e.g., a scene named MyScene.tscn must reside in the same directory as MyScene.cs, and you must have selected MyScene.cs as the active tab in VSCode before running the launch profile. If GoDotTest is able to find a .tscn file with the same name in the same location, it will run the game in debug mode and load the scene. Naturally, Chickensoft recommends naming scenes after the C# script they use and keeping them in the same directory so that you can take advantage of this launch profile. âš ï¸ It's very easy to rename a script class but forget to rename the scene file, or vice-versa. When that happens, this launch profile will pass in the expected name of the scene file based on the script's name, but Godot will fail to find a scene with that name since the script name and scene name are not the same. ğŸ§ª Debug Tests Runs the game in debug mode, specifying the command line flags needed by GoDotTest to run the tests. Debugging works the same as usual, allowing you to set breakpoints within the game's C# test files. ğŸ”¬ Debug Current Test Debugs the game and loads the test class with the same name as the C# file that's actively selected in VSCode: e.g., a test file named MyTest.cs must contain a test class named MyTest, and you must have selected MyTest.cs as the active tab in VSCode before running the launch profile. âš ï¸ It's very easy to rename a test class but forget to rename the test file, or vice-versa. When that happens, this launch profile will pass in the name of the file but GoDotTest will fail to find a class with that name since the filename and class name are not the same. Note that each launch profile will trigger a build (see ./.vscode/tasks.json) before debugging the game. âš ï¸ Important: You must setup a GODOT environment variable for the launch configurations above. If you haven't done so already, please see the Chickensoft Setup Docs. ğŸ­ CI/CD This game includes various GitHub Actions workflows to help with development. ğŸš¥ Tests Tests run directly inside the GitHub runner machine (using chickensoft-games/setup-godot) on every push to the repository. If the tests fail to pass, the workflow will also fail to pass. You can configure which simulated graphics environments (vulkan and/or opengl3) you want to run tests on in .github/workflows/visual_tests.yaml. Currently, tests can only be run from the ubuntu runners. If you know how to make the workflow install mesa and a virtual window manager on macOS and Windows, we'd love to hear from you! Tests are executed by running the Godot test project in ProjectStack from the command line and passing in the relevant arguments to Godot so that GoDotTest can discover and run tests. ğŸ§‘â€ğŸ« Spellcheck A spell check runs on every push to the repository. The spellcheck workflow settings can be configured in .github/workflows/spellcheck.yaml. The Code Spell Checker plugin for VSCode is recommended to help you catch typos before you commit them. If you need add a word to the dictionary or ignore a certain path, you can edit the project's cspell.json file. You can also words to the local cspell.json file from VSCode by hovering over a misspelled word and selecting Quick Fix... and then Add \"{word}\" to config: cspell.json. ğŸ—‚ Version Change The included workflow in .github/workflows/version_change.yaml can be manually dispatched to open a pull request that replaces the version number in ProjectStack.csproj with the version you specify in the workflow's inputs. ğŸ“¦ Publish to Nuget The included workflow in .github/workflows/publish.yaml can be manually dispatched when you're ready to publish your package to Nuget. To publish to nuget, you need a repository or organization secret named NUGET_API_KEY that contains your Nuget API key. The NUGET_API_KEY must be a GitHub actions secret to keep it safe! ğŸš Renovatebot This repository includes a renovate.json configuration for use with Renovatebot. Renovatebot can automatically open pull requests to help you keep your dependencies up to date when it detects new dependency versions have been released. Because Godot has such a rapid release cycle, automating dependency updates can be a huge time saver if you're trying to stay on the latest version of Godot. Unlike Dependabot, Renovatebot is able to combine all dependency updates into a single pull request â€” a must-have for Godot C# repositories where each sub-project needs the same Godot.NET.Sdk versions. If dependency version bumps were split across multiple repositories, the builds would fail in CI. The easiest way to add Renovatebot to your repository is to install it from the GitHub Marketplace. Note that you have to grant it access to each organization and repository you want it to monitor. The included renovate.json includes a few configuration options to limit how often Renovatebot can open pull requests as well as regex's to filter out some poorly versioned dependencies to prevent invalid dependency version updates. ğŸ£ Package generated from a ğŸ¤ Chickensoft Template â€” https://chickensoft.games"
  },
  "api/ProjectStack.CardTest.html": {
    "href": "api/ProjectStack.CardTest.html",
    "title": "CardTest ç±» | ProjectStack",
    "keywords": "CardTest ç±» å‘½åç©ºé—´ ProjectStack ç¨‹åºé›† ProjectStack.dll public class CardTest : TestClass ç»§æ‰¿ object TestClass CardTest æ„é€ å‡½æ•° CardTest(Node) public CardTest(Node testScene) å‚æ•° testScene Node æ–¹æ³• Setup() [Setup(26)] public void Setup() SetupAll() [SetupAll(19)] public void SetupAll() TestBottomCards() [Test(46)] public void TestBottomCards() TestDisconnectTopCard() [Test(56)] public void TestDisconnectTopCard() TestTopCards() [Test(36)] public void TestTopCards()"
  },
  "api/ProjectStack.Command.CommandAdapter.html": {
    "href": "api/ProjectStack.Command.CommandAdapter.html",
    "title": "CommandAdapter ç±» | ProjectStack",
    "keywords": "CommandAdapter ç±» å‘½åç©ºé—´ ProjectStack.Command ç¨‹åºé›† ProjectStack.dll [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Command/CommandAdapter.cs\")] public class CommandAdapter : Node ç»§æ‰¿ object GodotObject Node CommandAdapter å±æ€§ Metatype Generated metatype information. public IMetatype Metatype { get; } å±æ€§å€¼ IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } å±æ€§å€¼ MixinBlackboard æ–¹æ³• CreateNewCard(ResourceLocation) public void CreateNewCard(ResourceLocation id) å‚æ•° id ResourceLocation CreateNewCard(string) public void CreateNewCard(string id) å‚æ•° id string CreateNewCardStack(List<ResourceLocation>) public void CreateNewCardStack(List<ResourceLocation> ids) å‚æ•° ids List<ResourceLocation> CreateNewCardStack(string[]) public void CreateNewCardStack(string[] ids) å‚æ•° ids string[] GetCardMate(ResourceLocation) public ResourceLocation GetCardMate(ResourceLocation id) å‚æ•° id ResourceLocation è¿”å› ResourceLocation GetCardMate(string) public ResourceLocation GetCardMate(string id) å‚æ•° id string è¿”å› ResourceLocation GetRegisteredCardMetaIds() public string[] GetRegisteredCardMetaIds() è¿”å› string[] HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data."
  },
  "api/ProjectStack.Command.html": {
    "href": "api/ProjectStack.Command.html",
    "title": "ProjectStack.Command å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Command å‘½åç©ºé—´ ç±» CommandAdapter"
  },
  "api/ProjectStack.Common.Card.CardMeta.html": {
    "href": "api/ProjectStack.Common.Card.CardMeta.html",
    "title": "CardMeta ç±» | ProjectStack",
    "keywords": "CardMeta ç±» å‘½åç©ºé—´ ProjectStack.Common.Card ç¨‹åºé›† ProjectStack.dll public record CardMeta ç»§æ‰¿ object CardMeta æ„é€ å‡½æ•° CardMeta(ResourceLocation, string, string, ResourceLocation) public CardMeta(ResourceLocation Id, string Name, string Description, ResourceLocation Type) å‚æ•° Id ResourceLocation Name string Description string Type ResourceLocation å±æ€§ Description public string Description { get; init; } å±æ€§å€¼ string Id public ResourceLocation Id { get; init; } å±æ€§å€¼ ResourceLocation Name public string Name { get; init; } å±æ€§å€¼ string Type public ResourceLocation Type { get; init; } å±æ€§å€¼ ResourceLocation æ–¹æ³• Create(string) public static CardMeta Create(string id) å‚æ•° id string è¿”å› CardMeta"
  },
  "api/ProjectStack.Common.Card.CardMetaRegistrationHelper.html": {
    "href": "api/ProjectStack.Common.Card.CardMetaRegistrationHelper.html",
    "title": "CardMetaRegistrationHelper ç±» | ProjectStack",
    "keywords": "CardMetaRegistrationHelper ç±» å‘½åç©ºé—´ ProjectStack.Common.Card ç¨‹åºé›† ProjectStack.dll public class CardMetaRegistrationHelper ç»§æ‰¿ object CardMetaRegistrationHelper æ„é€ å‡½æ•° CardMetaRegistrationHelper(IServiceCollection) public CardMetaRegistrationHelper(IServiceCollection services) å‚æ•° services IServiceCollection æ–¹æ³• Add(CardMeta) public CardMetaRegistrationHelper Add(CardMeta cardMeta) å‚æ•° cardMeta CardMeta è¿”å› CardMetaRegistrationHelper End() public IServiceCollection End() è¿”å› IServiceCollection"
  },
  "api/ProjectStack.Common.Card.CardStack.html": {
    "href": "api/ProjectStack.Common.Card.CardStack.html",
    "title": "CardStack ç±» | ProjectStack",
    "keywords": "CardStack ç±» å‘½åç©ºé—´ ProjectStack.Common.Card ç¨‹åºé›† ProjectStack.dll public record CardStack : ICardStack ç»§æ‰¿ object CardStack å®ç° ICardStack æ„é€ å‡½æ•° CardStack(IImmutableList<Card>) public CardStack(IImmutableList<Card> Cards) å‚æ•° Cards IImmutableList<Card> å±æ€§ Cards public IImmutableList<Card> Cards { get; init; } å±æ€§å€¼ IImmutableList<Card>"
  },
  "api/ProjectStack.Common.Card.ICardStack.html": {
    "href": "api/ProjectStack.Common.Card.ICardStack.html",
    "title": "ICardStack æ¥å£ | ProjectStack",
    "keywords": "ICardStack æ¥å£ å‘½åç©ºé—´ ProjectStack.Common.Card ç¨‹åºé›† ProjectStack.dll public interface ICardStack å±æ€§ Cards IImmutableList<Card> Cards { get; } å±æ€§å€¼ IImmutableList<Card>"
  },
  "api/ProjectStack.Common.Card.html": {
    "href": "api/ProjectStack.Common.Card.html",
    "title": "ProjectStack.Common.Card å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Common.Card å‘½åç©ºé—´ ç±» CardMeta CardMetaRegistrationHelper CardStack æ¥å£ ICardStack"
  },
  "api/ProjectStack.Common.Recipe.AbstractRecipe-1.html": {
    "href": "api/ProjectStack.Common.Recipe.AbstractRecipe-1.html",
    "title": "AbstractRecipe<TRecipeInput> ç±» | ProjectStack",
    "keywords": "AbstractRecipe<TRecipeInput> ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public abstract class AbstractRecipe<TRecipeInput> ç±»å‹å‚æ•° TRecipeInput ç»§æ‰¿ object AbstractRecipe<TRecipeInput> æ–¹æ³• Assmble(TRecipeInput, JsonObject) public abstract RecipeOutput Assmble(TRecipeInput recipeInput, JsonObject ntj) å‚æ•° recipeInput TRecipeInput ntj JsonObject è¿”å› RecipeOutput Matchs(TRecipeInput, JsonObject) public abstract bool Matchs(TRecipeInput recipeInput, JsonObject ntj) å‚æ•° recipeInput TRecipeInput ntj JsonObject è¿”å› bool Type() public abstract ResourceLocation Type() è¿”å› ResourceLocation"
  },
  "api/ProjectStack.Common.Recipe.CardMetaMatchRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.CardMetaMatchRecipe.html",
    "title": "CardMetaMatchRecipe ç±» | ProjectStack",
    "keywords": "CardMetaMatchRecipe ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public class CardMetaMatchRecipe : IRecipe ç»§æ‰¿ object CardMetaMatchRecipe å®ç° IRecipe æ„é€ å‡½æ•° CardMetaMatchRecipe(IList<CardMeta>, IList<CardMeta>, bool) public CardMetaMatchRecipe(IList<CardMeta> requiredCardMetas, IList<CardMeta> producedCardMetas, bool isNeedOrder = false) å‚æ•° requiredCardMetas IList<CardMeta> producedCardMetas IList<CardMeta> isNeedOrder bool å±æ€§ CardViewCount é…æ–¹éœ€è¦æ£€æŸ¥çš„å¡ç‰Œæ•°é‡ã€‚ä¸ºnullæ—¶è¡¨ç¤ºä¸ç¡®å®šã€‚ public uint? CardViewCount { get; } å±æ€§å€¼ uint? IsNeedOrder public bool IsNeedOrder { get; set; } å±æ€§å€¼ bool ProducedCardMetas public IList<CardMeta> ProducedCardMetas { get; set; } å±æ€§å€¼ IList<CardMeta> RequiredCardMetas public IList<CardMeta> RequiredCardMetas { get; set; } å±æ€§å€¼ IList<CardMeta> æ–¹æ³• Execute(ICardStack) è®¡ç®—é…æ–¹ç»“æœã€‚ public RecipeResult Execute(ICardStack cardStack) å‚æ•° cardStack ICardStack éœ€è¦è¿›è¡Œè®¡ç®—çš„å¡å † è¿”å› RecipeResult é…æ–¹è¾“å‡º"
  },
  "api/ProjectStack.Common.Recipe.IRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.IRecipe.html",
    "title": "IRecipe æ¥å£ | ProjectStack",
    "keywords": "IRecipe æ¥å£ å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public interface IRecipe å±æ€§ CardViewCount é…æ–¹éœ€è¦æ£€æŸ¥çš„å¡ç‰Œæ•°é‡ã€‚ä¸ºnullæ—¶è¡¨ç¤ºä¸ç¡®å®šã€‚ uint? CardViewCount { get; } å±æ€§å€¼ uint? æ–¹æ³• Execute(ICardStack) è®¡ç®—é…æ–¹ç»“æœã€‚ RecipeResult Execute(ICardStack cardStack) å‚æ•° cardStack ICardStack éœ€è¦è¿›è¡Œè®¡ç®—çš„å¡å † è¿”å› RecipeResult é…æ–¹è¾“å‡º"
  },
  "api/ProjectStack.Common.Recipe.IRecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.IRecipeInput.html",
    "title": "IRecipeInput æ¥å£ | ProjectStack",
    "keywords": "IRecipeInput æ¥å£ å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public interface IRecipeInput"
  },
  "api/ProjectStack.Common.Recipe.RecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeInput.html",
    "title": "RecipeInput ç±» | ProjectStack",
    "keywords": "RecipeInput ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public abstract record RecipeInput ç»§æ‰¿ object RecipeInput Derived ScriptRecipeInput æ–¹æ³• Assemble(Card) public abstract Card Assemble(Card card) å‚æ•° card Card è¿”å› Card IsMatch(Card) public abstract bool IsMatch(Card card) å‚æ•° card Card è¿”å› bool"
  },
  "api/ProjectStack.Common.Recipe.RecipeOutput.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeOutput.html",
    "title": "RecipeOutput ç±» | ProjectStack",
    "keywords": "RecipeOutput ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public record RecipeOutput ç»§æ‰¿ object RecipeOutput æ„é€ å‡½æ•° RecipeOutput(List<Card>, JsonObject) public RecipeOutput(List<Card> Cards, JsonObject Ntj) å‚æ•° Cards List<Card> Ntj JsonObject å±æ€§ Cards public List<Card> Cards { get; init; } å±æ€§å€¼ List<Card> Ntj public JsonObject Ntj { get; init; } å±æ€§å€¼ JsonObject"
  },
  "api/ProjectStack.Common.Recipe.RecipeRegistrationHelper.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeRegistrationHelper.html",
    "title": "RecipeRegistrationHelper ç±» | ProjectStack",
    "keywords": "RecipeRegistrationHelper ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public class RecipeRegistrationHelper ç»§æ‰¿ object RecipeRegistrationHelper æ„é€ å‡½æ•° RecipeRegistrationHelper(IServiceCollection) public RecipeRegistrationHelper(IServiceCollection services) å‚æ•° services IServiceCollection æ–¹æ³• Add(IRecipe) public RecipeRegistrationHelper Add(IRecipe recipe) å‚æ•° recipe IRecipe è¿”å› RecipeRegistrationHelper End() public IServiceCollection End() è¿”å› IServiceCollection"
  },
  "api/ProjectStack.Common.Recipe.RecipeResult.html": {
    "href": "api/ProjectStack.Common.Recipe.RecipeResult.html",
    "title": "RecipeResult ç±» | ProjectStack",
    "keywords": "RecipeResult ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public record RecipeResult ç»§æ‰¿ object RecipeResult æ„é€ å‡½æ•° RecipeResult(bool, IEnumerable<Card>, IEnumerable<Card>) public RecipeResult(bool IsMatch, IEnumerable<Card> ConsumedCards, IEnumerable<Card> ProducedCards) å‚æ•° IsMatch bool ConsumedCards IEnumerable<Card> ProducedCards IEnumerable<Card> å±æ€§ ConsumedCards public IEnumerable<Card> ConsumedCards { get; init; } å±æ€§å€¼ IEnumerable<Card> IsMatch public bool IsMatch { get; init; } å±æ€§å€¼ bool ProducedCards public IEnumerable<Card> ProducedCards { get; init; } å±æ€§å€¼ IEnumerable<Card>"
  },
  "api/ProjectStack.Common.Recipe.ScriptRecipeInput.ScriptContext.html": {
    "href": "api/ProjectStack.Common.Recipe.ScriptRecipeInput.ScriptContext.html",
    "title": "ScriptRecipeInput.ScriptContext ç±» | ProjectStack",
    "keywords": "ScriptRecipeInput.ScriptContext ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public class ScriptRecipeInput.ScriptContext ç»§æ‰¿ object ScriptRecipeInput.ScriptContext å­—æ®µ card public Card card å­—æ®µå€¼ Card"
  },
  "api/ProjectStack.Common.Recipe.ScriptRecipeInput.html": {
    "href": "api/ProjectStack.Common.Recipe.ScriptRecipeInput.html",
    "title": "ScriptRecipeInput ç±» | ProjectStack",
    "keywords": "ScriptRecipeInput ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public record ScriptRecipeInput : RecipeInput ç»§æ‰¿ object RecipeInput ScriptRecipeInput æ„é€ å‡½æ•° ScriptRecipeInput() public ScriptRecipeInput() å±æ€§ AssembleScript public string AssembleScript { get; init; } å±æ€§å€¼ string AssembleScriptRunner public ScriptRunner<Card> AssembleScriptRunner { get; } å±æ€§å€¼ ScriptRunner<Card> MatchScript public string MatchScript { get; init; } å±æ€§å€¼ string MatchScriptRunner public ScriptRunner<bool> MatchScriptRunner { get; } å±æ€§å€¼ ScriptRunner<bool> æ–¹æ³• Assemble(Card) public override Card Assemble(Card card) å‚æ•° card Card è¿”å› Card IsMatch(Card) public override bool IsMatch(Card card) å‚æ•° card Card è¿”å› bool"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.Ingredient.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.Ingredient.html",
    "title": "SimpleRecipe.Ingredient ç±» | ProjectStack",
    "keywords": "SimpleRecipe.Ingredient ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public record SimpleRecipe.Ingredient ç»§æ‰¿ object SimpleRecipe.Ingredient æ„é€ å‡½æ•° Ingredient(ResourceLocation, int, bool) public Ingredient(ResourceLocation CardId, int Quantity, bool Consumed) å‚æ•° CardId ResourceLocation Quantity int Consumed bool å±æ€§ CardId public ResourceLocation CardId { get; init; } å±æ€§å€¼ ResourceLocation Consumed public bool Consumed { get; init; } å±æ€§å€¼ bool Quantity public int Quantity { get; init; } å±æ€§å€¼ int"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.Product.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.Product.html",
    "title": "SimpleRecipe.Product ç±» | ProjectStack",
    "keywords": "SimpleRecipe.Product ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll public record SimpleRecipe.Product ç»§æ‰¿ object SimpleRecipe.Product æ„é€ å‡½æ•° Product(ResourceLocation, int) public Product(ResourceLocation CardId, int Quantity) å‚æ•° CardId ResourceLocation Quantity int å±æ€§ CardId public ResourceLocation CardId { get; init; } å±æ€§å€¼ ResourceLocation Quantity public int Quantity { get; init; } å±æ€§å€¼ int"
  },
  "api/ProjectStack.Common.Recipe.SimpleRecipe.html": {
    "href": "api/ProjectStack.Common.Recipe.SimpleRecipe.html",
    "title": "SimpleRecipe ç±» | ProjectStack",
    "keywords": "SimpleRecipe ç±» å‘½åç©ºé—´ ProjectStack.Common.Recipe ç¨‹åºé›† ProjectStack.dll è¡¨ç¤ºé…æ–¹çš„æ•°æ®ç»“æ„ public record SimpleRecipe ç»§æ‰¿ object SimpleRecipe æ„é€ å‡½æ•° SimpleRecipe(ResourceLocation, string, string, float, IImmutableList<Ingredient>, IImmutableList<Product>) è¡¨ç¤ºé…æ–¹çš„æ•°æ®ç»“æ„ public SimpleRecipe(ResourceLocation Id, string Name, string Description, float Production, IImmutableList<SimpleRecipe.Ingredient> Ingredients, IImmutableList<SimpleRecipe.Product> Products) å‚æ•° Id ResourceLocation é…æ–¹æ ‡è¯†ç¬¦ Name string Description string Production float ç”Ÿäº§åŠ›æ¶ˆè€— Ingredients IImmutableList<SimpleRecipe.Ingredient> åŸæ–™ Products IImmutableList<SimpleRecipe.Product> äº§å“ å±æ€§ Description public string Description { get; init; } å±æ€§å€¼ string Id é…æ–¹æ ‡è¯†ç¬¦ public ResourceLocation Id { get; init; } å±æ€§å€¼ ResourceLocation Ingredients åŸæ–™ public IImmutableList<SimpleRecipe.Ingredient> Ingredients { get; init; } å±æ€§å€¼ IImmutableList<SimpleRecipe.Ingredient> Name public string Name { get; init; } å±æ€§å€¼ string Production ç”Ÿäº§åŠ›æ¶ˆè€— public float Production { get; init; } å±æ€§å€¼ float Products äº§å“ public IImmutableList<SimpleRecipe.Product> Products { get; init; } å±æ€§å€¼ IImmutableList<SimpleRecipe.Product> æ–¹æ³• SatisfactionCheck(IImmutableList<CardMeta>) public bool SatisfactionCheck(IImmutableList<CardMeta> cards) å‚æ•° cards IImmutableList<CardMeta> è¿”å› bool"
  },
  "api/ProjectStack.Common.Recipe.html": {
    "href": "api/ProjectStack.Common.Recipe.html",
    "title": "ProjectStack.Common.Recipe å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Common.Recipe å‘½åç©ºé—´ ç±» AbstractRecipe<TRecipeInput> CardMetaMatchRecipe RecipeInput RecipeOutput RecipeRegistrationHelper RecipeResult ScriptRecipeInput ScriptRecipeInput.ScriptContext SimpleRecipe è¡¨ç¤ºé…æ–¹çš„æ•°æ®ç»“æ„ SimpleRecipe.Ingredient SimpleRecipe.Product æ¥å£ IRecipe IRecipeInput"
  },
  "api/ProjectStack.Common.ResourceLocation.html": {
    "href": "api/ProjectStack.Common.ResourceLocation.html",
    "title": "ResourceLocation ç±» | ProjectStack",
    "keywords": "ResourceLocation ç±» å‘½åç©ºé—´ ProjectStack.Common ç¨‹åºé›† ProjectStack.dll public record ResourceLocation ç»§æ‰¿ object ResourceLocation æ„é€ å‡½æ•° ResourceLocation(string, string) public ResourceLocation(string Namespace, string Path) å‚æ•° Namespace string Path string å±æ€§ EMPTY public static ResourceLocation EMPTY { get; } å±æ€§å€¼ ResourceLocation GetNamespace public string GetNamespace { get; } å±æ€§å€¼ string GetPath public string GetPath { get; } å±æ€§å€¼ string Namespace public string Namespace { get; init; } å±æ€§å€¼ string Path public string Path { get; init; } å±æ€§å€¼ string æ–¹æ³• DefaultNamespaceAndPath(string) public static ResourceLocation DefaultNamespaceAndPath(string path) å‚æ•° path string è¿”å› ResourceLocation FromNamespaceAndPath(string, string) public static ResourceLocation FromNamespaceAndPath(string @namespace, string path) å‚æ•° namespace string path string è¿”å› ResourceLocation GetResLoc() public string GetResLoc() è¿”å› string GetResLocWithPath(string) public string GetResLocWithPath(string p) å‚æ•° p string è¿”å› string GetResLocWithoutPrefix(string) public string GetResLocWithoutPrefix(string p) å‚æ•° p string è¿”å› string Parse(string) public static ResourceLocation Parse(string fullPath) å‚æ•° fullPath string è¿”å› ResourceLocation ToString() Returns a string that represents the current object. public override string ToString() è¿”å› string A string that represents the current object."
  },
  "api/ProjectStack.Common.html": {
    "href": "api/ProjectStack.Common.html",
    "title": "ProjectStack.Common å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Common å‘½åç©ºé—´ ç±» ResourceLocation"
  },
  "api/ProjectStack.Component.Card.TaskNotifier-1.html": {
    "href": "api/ProjectStack.Component.Card.TaskNotifier-1.html",
    "title": "Card.TaskNotifier<T> ç±» | ProjectStack",
    "keywords": "Card.TaskNotifier<T> ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll A wrapping class that can hold a Task<TResult> value. protected sealed class Card.TaskNotifier<T> ç±»å‹å‚æ•° T The type of value for the wrapped Task<TResult> instance. ç»§æ‰¿ object Card.TaskNotifier<T> è¿ç®—ç¬¦ implicit operator Task<T>?(TaskNotifier<T>?) Unwraps the Task<TResult> value stored in the current instance. public static implicit operator Task<T>?(Card.TaskNotifier<T>? notifier) å‚æ•° notifier Card.TaskNotifier<T> The input Card.TaskNotifier<T> instance. è¿”å› Task<T>"
  },
  "api/ProjectStack.Component.Card.TaskNotifier.html": {
    "href": "api/ProjectStack.Component.Card.TaskNotifier.html",
    "title": "Card.TaskNotifier ç±» | ProjectStack",
    "keywords": "Card.TaskNotifier ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll A wrapping class that can hold a Task value. protected sealed class Card.TaskNotifier ç»§æ‰¿ object Card.TaskNotifier è¿ç®—ç¬¦ implicit operator Task?(TaskNotifier?) Unwraps the Task value stored in the current instance. public static implicit operator Task?(Card.TaskNotifier? notifier) å‚æ•° notifier Card.TaskNotifier The input Card.TaskNotifier<T> instance. è¿”å› Task"
  },
  "api/ProjectStack.Component.Card.html": {
    "href": "api/ProjectStack.Component.Card.html",
    "title": "Card ç±» | ProjectStack",
    "keywords": "Card ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. [ObservableObject] [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Component/Card.cs\")] public class Card : Node2D, INtjObject ç»§æ‰¿ object GodotObject Node CanvasItem Node2D Card å®ç° INtjObject æ„é€ å‡½æ•° Card() public Card() å­—æ®µ ForceMotion public bool ForceMotion å­—æ®µå€¼ bool InMoveing public bool InMoveing å­—æ®µå€¼ bool å±æ€§ BottomCard public Card? BottomCard { get; set; } å±æ€§å€¼ Card BottomCards public IImmutableList<Card> BottomCards { get; } å±æ€§å€¼ IImmutableList<Card> CardMeta public CardMeta CardMeta { get; set; } å±æ€§å€¼ CardMeta CardNameLabel public Label? CardNameLabel { get; } å±æ€§å€¼ Label CardStack public ICardStack CardStack { get; } å±æ€§å€¼ ICardStack CharacterBody public CharacterBody2D? CharacterBody { get; } å±æ€§å€¼ CharacterBody2D CurrentStack public IImmutableList<Card> CurrentStack { get; } å±æ€§å€¼ IImmutableList<Card> IsRoot public bool IsRoot { get; } å±æ€§å€¼ bool IsUppest public bool IsUppest { get; } å±æ€§å€¼ bool Metatype Generated metatype information. public IMetatype Metatype { get; } å±æ€§å€¼ IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } å±æ€§å€¼ MixinBlackboard Ntj public JsonObject Ntj { get; set; } å±æ€§å€¼ JsonObject OnDrag public bool OnDrag { get; set; } å±æ€§å€¼ bool Panel public Control? Panel { get; } å±æ€§å€¼ Control RootCard public Card RootCard { get; } å±æ€§å€¼ Card TargetPosition public Vector2 TargetPosition { get; set; } å±æ€§å€¼ Vector2 TextureRect public TextureRect? TextureRect { get; } å±æ€§å€¼ TextureRect TopCard public Card? TopCard { get; set; } å±æ€§å€¼ Card TopCards public IImmutableList<Card> TopCards { get; } å±æ€§å€¼ IImmutableList<Card> UppestCard public Card UppestCard { get; } å±æ€§å€¼ Card æ–¹æ³• GetGodotClassPropertyValue(in godot_string_name, out godot_variant) Get the value of a property contained in this class. This method is used by Godot to retrieve property values. Do not call or override this method. protected override bool GetGodotClassPropertyValue(in godot_string_name name, out godot_variant value) å‚æ•° name godot_string_name Name of the property to get. value godot_variant Value of the property if it was found. è¿”å› bool true if a property with the given name was found. GetNearestSameCard(Card) public Card? GetNearestSameCard(Card card) å‚æ•° card Card è¿”å› Card HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool OnCardAreaEntered(Area2D) public void OnCardAreaEntered(Area2D body) å‚æ•° body Area2D OnCardAreaExited(Area2D) public void OnCardAreaExited(Area2D body) å‚æ•° body Area2D OnCardStackChanged() è§¦å‘CardStackChangedäº‹ä»¶ã€‚ protected virtual void OnCardStackChanged() OnPropertyChanged(PropertyChangedEventArgs) Raises the PropertyChanged event. protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) å‚æ•° e PropertyChangedEventArgs The input PropertyChangedEventArgs instance. OnPropertyChanged(string?) Raises the PropertyChanged event. protected void OnPropertyChanged(string? propertyName = null) å‚æ•° propertyName string (optional) The name of the property that changed. OnPropertyChanging(PropertyChangingEventArgs) Raises the PropertyChanging event. protected virtual void OnPropertyChanging(PropertyChangingEventArgs e) å‚æ•° e PropertyChangingEventArgs The input PropertyChangingEventArgs instance. OnPropertyChanging(string?) Raises the PropertyChanging event. protected void OnPropertyChanging(string? propertyName = null) å‚æ•° propertyName string (optional) The name of the property that changed. OnReady() Notification received when the node is ready. public void OnReady() RefreshTexture() public void RefreshTexture() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data. SetGodotClassPropertyValue(in godot_string_name, in godot_variant) Set the value of a property contained in this class. This method is used by Godot to assign property values. Do not call or override this method. protected override bool SetGodotClassPropertyValue(in godot_string_name name, in godot_variant value) å‚æ•° name godot_string_name Name of the property to set. value godot_variant Value to set the property to if it was found. è¿”å› bool true if a property with the given name was found. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, Action<Task?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion(ref Card.TaskNotifier? taskNotifier, Task? newValue, Action<Task?> callback, string? propertyName = null) å‚æ•° taskNotifier Card.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. callback Action<Task> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the Card.TaskNotifier type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The Card.TaskNotifier type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier myTask; public Task MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion(ref Card.TaskNotifier? taskNotifier, Task? newValue, string? propertyName = null) å‚æ•° taskNotifier Card.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task instance passed as argument is in any particular state. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, Action<Task<T>?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion<T>(ref Card.TaskNotifier<T>? taskNotifier, Task<T>? newValue, Action<Task<T>?> callback, string? propertyName = null) å‚æ•° taskNotifier Card.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. callback Action<Task<T>> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of result for the Task<TResult> to set and monitor. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the Card.TaskNotifier<T> type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The Card.TaskNotifier<T> type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier<int> myTask; public Task<int> MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion<T>(ref Card.TaskNotifier<T>? taskNotifier, Task<T>? newValue, string? propertyName = null) å‚æ•° taskNotifier Card.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of result for the Task<TResult> to set and monitor. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task<TResult> instance passed as argument is in any particular state. SetProperty<T>(T, T, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. This overload is much less efficient than SetProperty<T>(ref T, T, string?) and it should only be used when the former is not viable (eg. when the target property being updated does not directly expose a backing field that can be passed by reference). For performance reasons, it is recommended to use a stateful callback if possible through the SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) whenever possible instead of this overload, as that will allow the C# compiler to cache the input callback and reduce the memory allocations. More info on that overload are available in the related XML docs. This overload is here for completeness and in cases where that is not applicable. protected bool SetProperty<T>(T oldValue, T newValue, Action<T> callback, string? propertyName = null) å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<T>(T, T, IEqualityComparer<T>, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(T, T, Action<T>, string?). protected bool SetProperty<T>(T oldValue, T newValue, IEqualityComparer<T> comparer, Action<T> callback, string? propertyName = null) å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. SetProperty<T>(ref T, T, IEqualityComparer<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(ref T, T, string?). protected bool SetProperty<T>(ref T field, T newValue, IEqualityComparer<T> comparer, string? propertyName = null) å‚æ•° field T The field storing the property's value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. SetProperty<T>(ref T, T, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. protected bool SetProperty<T>(ref T field, T newValue, string? propertyName = null) å‚æ•° field T The field storing the property's value. newValue T The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<TModel, T>(T, T, IEqualityComparer<T>, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. See additional notes about this overload in SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?). protected bool SetProperty<TModel, T>(T oldValue, T newValue, IEqualityComparer<T> comparer, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° TModel The type of model whose property (or field) to set. T The type of property (or field) to set. SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. This type is useful when creating wrapping, bindable objects that operate over models that lack support for notification (eg. for CRUD operations). Suppose we have this model (eg. for a database row in a table): public class Person { public string Name { get; set; } } We can then use a property to wrap instances of this type into our observable model (which supports notifications), injecting the notification to the properties of that model, like so: [ObservableObject] public class BindablePerson { public Model { get; } public BindablePerson(Person model) { Model = model; } public string Name { get => Model.Name; set => Set(Model.Name, value, Model, (model, name) => model.Name = name); } } This way we can then use the wrapping object in our application, and all those \"proxy\" properties will also raise notifications when changed. Note that this method is not meant to be a replacement for SetProperty<T>(ref T, T, string?), and it should only be used when relaying properties to a model that doesn't support notifications, and only if you can't implement notifications to that model directly (eg. by having it inherit from ObservableObject). The syntax relies on passing the target model and a stateless callback to allow the C# compiler to cache the function, which results in much better performance and no memory usage. protected bool SetProperty<TModel, T>(T oldValue, T newValue, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° TModel The type of model whose property (or field) to set. T The type of property (or field) to set. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. UpdateAllZIndex() public void UpdateAllZIndex() UpdateRecipe() public void UpdateRecipe() UpdateZIndex() public void UpdateZIndex() _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) å‚æ•° what int _Process(double) Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the delta time since the previous frame is not constant. delta is in seconds. It is only called if processing is enabled, which is done automatically if this method is overridden, and can be toggled with SetProcess(bool). Corresponds to the Godot.Node.NotificationProcess notification in _Notification(int). Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan). public override void _Process(double delta) å‚æ•° delta double _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready() äº‹ä»¶ CardStackChanged å½“å¡å †å‘ç”Ÿå˜åŒ–æ—¶è§¦å‘ã€‚ public event Action<ICardStack>? CardStackChanged äº‹ä»¶ç±»å‹ Action<ICardStack> PropertyChanged Occurs when a property value changes. public event PropertyChangedEventHandler? PropertyChanged äº‹ä»¶ç±»å‹ PropertyChangedEventHandler PropertyChanging Occurs when a property value is changing. public event PropertyChangingEventHandler? PropertyChanging äº‹ä»¶ç±»å‹ PropertyChangingEventHandler"
  },
  "api/ProjectStack.Component.InfoTab.TaskNotifier-1.html": {
    "href": "api/ProjectStack.Component.InfoTab.TaskNotifier-1.html",
    "title": "InfoTab.TaskNotifier<T> ç±» | ProjectStack",
    "keywords": "InfoTab.TaskNotifier<T> ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll A wrapping class that can hold a Task<TResult> value. protected sealed class InfoTab.TaskNotifier<T> ç±»å‹å‚æ•° T The type of value for the wrapped Task<TResult> instance. ç»§æ‰¿ object InfoTab.TaskNotifier<T> è¿ç®—ç¬¦ implicit operator Task<T>?(TaskNotifier<T>?) Unwraps the Task<TResult> value stored in the current instance. public static implicit operator Task<T>?(InfoTab.TaskNotifier<T>? notifier) å‚æ•° notifier InfoTab.TaskNotifier<T> The input InfoTab.TaskNotifier<T> instance. è¿”å› Task<T>"
  },
  "api/ProjectStack.Component.InfoTab.TaskNotifier.html": {
    "href": "api/ProjectStack.Component.InfoTab.TaskNotifier.html",
    "title": "InfoTab.TaskNotifier ç±» | ProjectStack",
    "keywords": "InfoTab.TaskNotifier ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll A wrapping class that can hold a Task value. protected sealed class InfoTab.TaskNotifier ç»§æ‰¿ object InfoTab.TaskNotifier è¿ç®—ç¬¦ implicit operator Task?(TaskNotifier?) Unwraps the Task value stored in the current instance. public static implicit operator Task?(InfoTab.TaskNotifier? notifier) å‚æ•° notifier InfoTab.TaskNotifier The input InfoTab.TaskNotifier<T> instance. è¿”å› Task"
  },
  "api/ProjectStack.Component.InfoTab.html": {
    "href": "api/ProjectStack.Component.InfoTab.html",
    "title": "InfoTab ç±» | ProjectStack",
    "keywords": "InfoTab ç±» å‘½åç©ºé—´ ProjectStack.Component ç¨‹åºé›† ProjectStack.dll Base class for all UI-related nodes. Godot.Control features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from Godot.Control and Godot.Container nodes. User Interface nodes and input Godot propagates input events via viewports. Each Godot.Viewport is responsible for propagating Godot.InputEvents to their child nodes. As the Godot.SceneTree.Root is a Godot.Window, this already happens automatically for all UI elements in your game. Input events are propagated through the Godot.SceneTree from the root node to all child nodes by calling Godot.Node._Input(Godot.InputEvent). For UI elements specifically, it makes more sense to override the virtual method Godot.Control._GuiInput(Godot.InputEvent), which filters out unrelated input events, such as by checking z-order, Godot.Control.MouseFilter, focus, or if the event was inside of the control's bounding box. Call Godot.Control.AcceptEvent() so no other node receives the event. Once you accept an input, it becomes handled so Godot.Node._UnhandledInput(Godot.InputEvent) will not process it. Only one Godot.Control node can be in focus. Only the node in focus will receive events. To get the focus, call Godot.Control.GrabFocus(). Godot.Control nodes lose focus when another node grabs it, or if you hide the node in focus. Sets Godot.Control.MouseFilter to Godot.Control.MouseFilterEnum.Ignore to tell a Godot.Control node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. Godot.Theme resources change the Control's appearance. If you change the Godot.Theme on a Godot.Control node, it affects all of its children. To override some of the theme's parameters, call one of the add_theme_*_override methods, like Godot.Control.AddThemeFontOverride(Godot.StringName, Godot.Font). You can override the theme with the Inspector. Note: Theme items are notGodot.GodotObject properties. This means you can't access their values using Godot.GodotObject.Get(Godot.StringName) and Godot.GodotObject.Set(Godot.StringName, Godot.Variant). Instead, use the get_theme_* and add_theme_*_override methods provided by this class. [ObservableObject] [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/scripts/Component/InfoTab.cs\")] public class InfoTab : Control ç»§æ‰¿ object GodotObject Node CanvasItem Control InfoTab å±æ€§ Metatype Generated metatype information. public IMetatype Metatype { get; } å±æ€§å€¼ IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } å±æ€§å€¼ MixinBlackboard æ–¹æ³• GetGodotClassPropertyValue(in godot_string_name, out godot_variant) Get the value of a property contained in this class. This method is used by Godot to retrieve property values. Do not call or override this method. protected override bool GetGodotClassPropertyValue(in godot_string_name name, out godot_variant value) å‚æ•° name godot_string_name Name of the property to get. value godot_variant Value of the property if it was found. è¿”å› bool true if a property with the given name was found. HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool OnProcess(double) Notification received from the tree every rendered frame when Godot.Node.IsPhysicsProcessing() returns true. public void OnProcess(double delta) å‚æ•° delta double Time since the last process update, in seconds. OnPropertyChanged(PropertyChangedEventArgs) Raises the PropertyChanged event. protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) å‚æ•° e PropertyChangedEventArgs The input PropertyChangedEventArgs instance. OnPropertyChanged(string?) Raises the PropertyChanged event. protected void OnPropertyChanged(string? propertyName = null) å‚æ•° propertyName string (optional) The name of the property that changed. OnPropertyChanging(PropertyChangingEventArgs) Raises the PropertyChanging event. protected virtual void OnPropertyChanging(PropertyChangingEventArgs e) å‚æ•° e PropertyChangingEventArgs The input PropertyChangingEventArgs instance. OnPropertyChanging(string?) Raises the PropertyChanging event. protected void OnPropertyChanging(string? propertyName = null) å‚æ•° propertyName string (optional) The name of the property that changed. OnReady() Notification received when the node is ready. public void OnReady() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data. SetGodotClassPropertyValue(in godot_string_name, in godot_variant) Set the value of a property contained in this class. This method is used by Godot to assign property values. Do not call or override this method. protected override bool SetGodotClassPropertyValue(in godot_string_name name, in godot_variant value) å‚æ•° name godot_string_name Name of the property to set. value godot_variant Value to set the property to if it was found. è¿”å› bool true if a property with the given name was found. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, Action<Task?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion(ref InfoTab.TaskNotifier? taskNotifier, Task? newValue, Action<Task?> callback, string? propertyName = null) å‚æ•° taskNotifier InfoTab.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. callback Action<Task> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion(ref TaskNotifier?, Task?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the InfoTab.TaskNotifier type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The InfoTab.TaskNotifier type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier myTask; public Task MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion(ref InfoTab.TaskNotifier? taskNotifier, Task? newValue, string? propertyName = null) å‚æ•° taskNotifier InfoTab.TaskNotifier The field notifier to modify. newValue Task The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task instance passed as argument is in any particular state. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, Action<Task<T>?>, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. This method is just like SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?), with the difference being an extra Action<T> parameter with a callback being invoked either immediately, if the new task has already completed or is null, or upon completion. protected bool SetPropertyAndNotifyOnCompletion<T>(ref InfoTab.TaskNotifier<T>? taskNotifier, Task<T>? newValue, Action<Task<T>?> callback, string? propertyName = null) å‚æ•° taskNotifier InfoTab.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. callback Action<Task<T>> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of result for the Task<TResult> to set and monitor. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetPropertyAndNotifyOnCompletion<T>(ref TaskNotifier<T>?, Task<T>?, string?) Compares the current and new values for a given field (which should be the backing field for a property). If the value has changed, raises the PropertyChanging event, updates the field and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method will also monitor the new value of the property (a generic Task) and will also raise the PropertyChanged again for the target property when it completes. This can be used to update bindings observing that Task or any of its properties. This method and its overload specifically rely on the InfoTab.TaskNotifier<T> type, which needs to be used in the backing field for the target Task property. The field doesn't need to be initialized, as this method will take care of doing that automatically. The InfoTab.TaskNotifier<T> type also includes an implicit operator, so it can be assigned to any Task instance directly. Here is a sample property declaration using this method: private TaskNotifier<int> myTask; public Task<int> MyTask { get => myTask; private set => SetAndNotifyOnCompletion(ref myTask, value); } protected bool SetPropertyAndNotifyOnCompletion<T>(ref InfoTab.TaskNotifier<T>? taskNotifier, Task<T>? newValue, string? propertyName = null) å‚æ•° taskNotifier InfoTab.TaskNotifier<T> The field notifier to modify. newValue Task<T> The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of result for the Task<TResult> to set and monitor. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. The return value being true only indicates that the new value being assigned to taskNotifier is different than the previous one, and it does not mean the new Task<TResult> instance passed as argument is in any particular state. SetProperty<T>(T, T, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. This overload is much less efficient than SetProperty<T>(ref T, T, string?) and it should only be used when the former is not viable (eg. when the target property being updated does not directly expose a backing field that can be passed by reference). For performance reasons, it is recommended to use a stateful callback if possible through the SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) whenever possible instead of this overload, as that will allow the C# compiler to cache the input callback and reduce the memory allocations. More info on that overload are available in the related XML docs. This overload is here for completeness and in cases where that is not applicable. protected bool SetProperty<T>(T oldValue, T newValue, Action<T> callback, string? propertyName = null) å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<T>(T, T, IEqualityComparer<T>, Action<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(T, T, Action<T>, string?). protected bool SetProperty<T>(T oldValue, T newValue, IEqualityComparer<T> comparer, Action<T> callback, string? propertyName = null) å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. callback Action<T> A callback to invoke to update the property value. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. SetProperty<T>(ref T, T, IEqualityComparer<T>, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. See additional notes about this overload in SetProperty<T>(ref T, T, string?). protected bool SetProperty<T>(ref T field, T newValue, IEqualityComparer<T> comparer, string? propertyName = null) å‚æ•° field T The field storing the property's value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. SetProperty<T>(ref T, T, string?) Compares the current and new values for a given property. If the value has changed, raises the PropertyChanging event, updates the property with the new value, then raises the PropertyChanged event. protected bool SetProperty<T>(ref T field, T newValue, string? propertyName = null) å‚æ•° field T The field storing the property's value. newValue T The property's value after the change occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° T The type of the property that changed. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. SetProperty<TModel, T>(T, T, IEqualityComparer<T>, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. See additional notes about this overload in SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?). protected bool SetProperty<TModel, T>(T oldValue, T newValue, IEqualityComparer<T> comparer, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. comparer IEqualityComparer<T> The IEqualityComparer<T> instance to use to compare the input values. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° TModel The type of model whose property (or field) to set. T The type of property (or field) to set. SetProperty<TModel, T>(T, T, TModel, Action<TModel, T>, string?) Compares the current and new values for a given nested property. If the value has changed, raises the PropertyChanging event, updates the property and then raises the PropertyChanged event. The behavior mirrors that of SetProperty<T>(ref T, T, string?), with the difference being that this method is used to relay properties from a wrapped model in the current instance. This type is useful when creating wrapping, bindable objects that operate over models that lack support for notification (eg. for CRUD operations). Suppose we have this model (eg. for a database row in a table): public class Person { public string Name { get; set; } } We can then use a property to wrap instances of this type into our observable model (which supports notifications), injecting the notification to the properties of that model, like so: [ObservableObject] public class BindablePerson { public Model { get; } public BindablePerson(Person model) { Model = model; } public string Name { get => Model.Name; set => Set(Model.Name, value, Model, (model, name) => model.Name = name); } } This way we can then use the wrapping object in our application, and all those \"proxy\" properties will also raise notifications when changed. Note that this method is not meant to be a replacement for SetProperty<T>(ref T, T, string?), and it should only be used when relaying properties to a model that doesn't support notifications, and only if you can't implement notifications to that model directly (eg. by having it inherit from ObservableObject). The syntax relies on passing the target model and a stateless callback to allow the C# compiler to cache the function, which results in much better performance and no memory usage. protected bool SetProperty<TModel, T>(T oldValue, T newValue, TModel model, Action<TModel, T> callback, string? propertyName = null) where TModel : class å‚æ•° oldValue T The current property value. newValue T The property's value after the change occurred. model TModel The model containing the property being updated. callback Action<TModel, T> The callback to invoke to set the target property value, if a change has occurred. propertyName string (optional) The name of the property that changed. è¿”å› bool true if the property was changed, false otherwise. ç±»å‹å‚æ•° TModel The type of model whose property (or field) to set. T The type of property (or field) to set. å¤‡æ³¨ The PropertyChanging and PropertyChanged events are not raised if the current and new value for the target property are the same. _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) å‚æ•° what int äº‹ä»¶ PropertyChanged Occurs when a property value changes. public event PropertyChangedEventHandler? PropertyChanged äº‹ä»¶ç±»å‹ PropertyChangedEventHandler PropertyChanging Occurs when a property value is changing. public event PropertyChangingEventHandler? PropertyChanging äº‹ä»¶ç±»å‹ PropertyChangingEventHandler"
  },
  "api/ProjectStack.Component.html": {
    "href": "api/ProjectStack.Component.html",
    "title": "ProjectStack.Component å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Component å‘½åç©ºé—´ ç±» Card A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. Card.TaskNotifier A wrapping class that can hold a Task value. Card.TaskNotifier<T> A wrapping class that can hold a Task<TResult> value. InfoTab Base class for all UI-related nodes. Godot.Control features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from Godot.Control and Godot.Container nodes. User Interface nodes and input Godot propagates input events via viewports. Each Godot.Viewport is responsible for propagating Godot.InputEvents to their child nodes. As the Godot.SceneTree.Root is a Godot.Window, this already happens automatically for all UI elements in your game. Input events are propagated through the Godot.SceneTree from the root node to all child nodes by calling Godot.Node._Input(Godot.InputEvent). For UI elements specifically, it makes more sense to override the virtual method Godot.Control._GuiInput(Godot.InputEvent), which filters out unrelated input events, such as by checking z-order, Godot.Control.MouseFilter, focus, or if the event was inside of the control's bounding box. Call Godot.Control.AcceptEvent() so no other node receives the event. Once you accept an input, it becomes handled so Godot.Node._UnhandledInput(Godot.InputEvent) will not process it. Only one Godot.Control node can be in focus. Only the node in focus will receive events. To get the focus, call Godot.Control.GrabFocus(). Godot.Control nodes lose focus when another node grabs it, or if you hide the node in focus. Sets Godot.Control.MouseFilter to Godot.Control.MouseFilterEnum.Ignore to tell a Godot.Control node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. Godot.Theme resources change the Control's appearance. If you change the Godot.Theme on a Godot.Control node, it affects all of its children. To override some of the theme's parameters, call one of the add_theme_*_override methods, like Godot.Control.AddThemeFontOverride(Godot.StringName, Godot.Font). You can override the theme with the Inspector. Note: Theme items are notGodot.GodotObject properties. This means you can't access their values using Godot.GodotObject.Get(Godot.StringName) and Godot.GodotObject.Set(Godot.StringName, Godot.Variant). Instead, use the get_theme_* and add_theme_*_override methods provided by this class. InfoTab.TaskNotifier A wrapping class that can hold a Task value. InfoTab.TaskNotifier<T> A wrapping class that can hold a Task<TResult> value."
  },
  "api/ProjectStack.Core.CardMgr.html": {
    "href": "api/ProjectStack.Core.CardMgr.html",
    "title": "CardMgr ç±» | ProjectStack",
    "keywords": "CardMgr ç±» å‘½åç©ºé—´ ProjectStack.Core ç¨‹åºé›† ProjectStack.dll [ScriptPath(\"res://src/scripts/Core/CardMgr.cs\")] public class CardMgr : Node ç»§æ‰¿ object GodotObject Node CardMgr æ–¹æ³• RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data."
  },
  "api/ProjectStack.Core.ServiceCollectionExtension.html": {
    "href": "api/ProjectStack.Core.ServiceCollectionExtension.html",
    "title": "ServiceCollectionExtension ç±» | ProjectStack",
    "keywords": "ServiceCollectionExtension ç±» å‘½åç©ºé—´ ProjectStack.Core ç¨‹åºé›† ProjectStack.dll public static class ServiceCollectionExtension ç»§æ‰¿ object ServiceCollectionExtension æ–¹æ³• ConfigureHoveredItemInfoDisplay(IServiceCollection) public static HoveredItemInfoDisplayRegistrationHelper ConfigureHoveredItemInfoDisplay(this IServiceCollection services) å‚æ•° services IServiceCollection è¿”å› HoveredItemInfoDisplayRegistrationHelper RegisterCardMetas(IServiceCollection) public static CardMetaRegistrationHelper RegisterCardMetas(this IServiceCollection services) å‚æ•° services IServiceCollection è¿”å› CardMetaRegistrationHelper RegisterRecipes(IServiceCollection) public static RecipeRegistrationHelper RegisterRecipes(this IServiceCollection services) å‚æ•° services IServiceCollection è¿”å› RecipeRegistrationHelper RegisterTextureLoader(IServiceCollection) public static TextureLoader RegisterTextureLoader(this IServiceCollection services) å‚æ•° services IServiceCollection è¿”å› TextureLoader"
  },
  "api/ProjectStack.Core.html": {
    "href": "api/ProjectStack.Core.html",
    "title": "ProjectStack.Core å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Core å‘½åç©ºé—´ ç±» CardMgr ServiceCollectionExtension"
  },
  "api/ProjectStack.Game.html": {
    "href": "api/ProjectStack.Game.html",
    "title": "Game ç±» | ProjectStack",
    "keywords": "Game ç±» å‘½åç©ºé—´ ProjectStack ç¨‹åºé›† ProjectStack.dll [Meta(new Type[] { typeof(IAutoNode) })] [ScriptPath(\"res://src/Game.cs\")] public class Game : Node2D ç»§æ‰¿ object GodotObject Node CanvasItem Node2D Game å±æ€§ Default public static Game Default { get; } å±æ€§å€¼ Game Metatype Generated metatype information. public IMetatype Metatype { get; } å±æ€§å€¼ IMetatype MixinState Arbitrary data that is shared between mixins. Mixins are free to store additional instance state in this blackboard. public MixinBlackboard MixinState { get; } å±æ€§å€¼ MixinBlackboard Recipes public IImmutableList<IRecipe> Recipes { get; } å±æ€§å€¼ IImmutableList<IRecipe> ServiceProvider public IServiceProvider ServiceProvider { get; } å±æ€§å€¼ IServiceProvider æ–¹æ³• HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool OnReady() Notification received when the node is ready. public void OnReady() RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data. Value() Value that is provided by the provider. public IServiceProvider Value() è¿”å› IServiceProvider _Notification(int) Called when the object receives a notification, which can be identified in what by comparing it with a constant. See also Notification(int, bool). public override void _Notification(int what) { if (what == NotificationPredelete) { GD.Print(\"Goodbye!\"); } } Note: The base Godot.GodotObject defines a few notifications (Godot.GodotObject.NotificationPostinitialize and Godot.GodotObject.NotificationPredelete). Inheriting classes such as Godot.Node define a lot more notifications, which are also received by this method. public override void _Notification(int what) å‚æ•° what int"
  },
  "api/ProjectStack.Launcher.html": {
    "href": "api/ProjectStack.Launcher.html",
    "title": "Launcher ç±» | ProjectStack",
    "keywords": "Launcher ç±» å‘½åç©ºé—´ ProjectStack ç¨‹åºé›† ProjectStack.dll [ScriptPath(\"res://src/Launcher.cs\")] public class Launcher : Node ç»§æ‰¿ object GodotObject Node Launcher æ–¹æ³• HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data. _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready()"
  },
  "api/ProjectStack.Main.html": {
    "href": "api/ProjectStack.Main.html",
    "title": "Main ç±» | ProjectStack",
    "keywords": "Main ç±» å‘½åç©ºé—´ ProjectStack ç¨‹åºé›† ProjectStack.dll [ScriptPath(\"res://src/Main.cs\")] public class Main : Node2D ç»§æ‰¿ object GodotObject Node CanvasItem Node2D Main æ–¹æ³• HasGodotClassMethod(in godot_string_name) Check if the type contains a method with the given name. This method is used by Godot to check if a method exists before invoking it. Do not call or override this method. protected override bool HasGodotClassMethod(in godot_string_name method) å‚æ•° method godot_string_name Name of the method to check for. è¿”å› bool InvokeGodotClassMethod(in godot_string_name, NativeVariantPtrArgs, out godot_variant) Invokes the method with the given name, using the given arguments. This method is used by Godot to invoke methods from the engine side. Do not call or override this method. protected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret) å‚æ•° method godot_string_name Name of the method to invoke. args NativeVariantPtrArgs Arguments to use with the invoked method. ret godot_variant Value returned by the invoked method. è¿”å› bool RestoreGodotObjectData(GodotSerializationInfo) Restores this instance's state after reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void RestoreGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object that contains the previously saved data. SaveGodotObjectData(GodotSerializationInfo) Saves this instance's state to be restored when reloading assemblies. Do not call or override this method. To add data to be saved and restored, implement Godot.ISerializationListener. protected override void SaveGodotObjectData(GodotSerializationInfo info) å‚æ•° info GodotSerializationInfo Object used to save the data. _Ready() Called when the node is \"ready\", i.e. when both the node and its children have entered the scene tree. If the node has children, their Godot.Node._Ready() callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the Godot.Node.NotificationReady notification in _Notification(int). See also the @onready annotation for variables. Usually used for initialization. For even earlier initialization, Godot.GodotObject.GodotObject() may be used. See also Godot.Node._EnterTree(). Note: This method may be called only once for each node. After removing a node from the scene tree and adding it again, Godot.Node._Ready() will not be called a second time. This can be bypassed by requesting another call with Godot.Node.RequestReady(), which may be called anywhere before adding the node again. public override void _Ready()"
  },
  "api/ProjectStack.NamedTagsBaseOnJson.INtjObject.html": {
    "href": "api/ProjectStack.NamedTagsBaseOnJson.INtjObject.html",
    "title": "INtjObject æ¥å£ | ProjectStack",
    "keywords": "INtjObject æ¥å£ å‘½åç©ºé—´ ProjectStack.NamedTagsBaseOnJson ç¨‹åºé›† ProjectStack.dll public interface INtjObject å±æ€§ Ntj JsonObject Ntj { get; } å±æ€§å€¼ JsonObject"
  },
  "api/ProjectStack.NamedTagsBaseOnJson.html": {
    "href": "api/ProjectStack.NamedTagsBaseOnJson.html",
    "title": "ProjectStack.NamedTagsBaseOnJson å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.NamedTagsBaseOnJson å‘½åç©ºé—´ æ¥å£ INtjObject"
  },
  "api/ProjectStack.Resource.TextureLoader.html": {
    "href": "api/ProjectStack.Resource.TextureLoader.html",
    "title": "TextureLoader ç±» | ProjectStack",
    "keywords": "TextureLoader ç±» å‘½åç©ºé—´ ProjectStack.Resource ç¨‹åºé›† ProjectStack.dll public class TextureLoader ç»§æ‰¿ object TextureLoader æ„é€ å‡½æ•° TextureLoader(IServiceCollection) public TextureLoader(IServiceCollection services) å‚æ•° services IServiceCollection æ–¹æ³• AddTextureDirectory(string) public TextureLoader AddTextureDirectory(string directoryPath) å‚æ•° directoryPath string è¿”å› TextureLoader End() public IServiceCollection End() è¿”å› IServiceCollection"
  },
  "api/ProjectStack.Resource.html": {
    "href": "api/ProjectStack.Resource.html",
    "title": "ProjectStack.Resource å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Resource å‘½åç©ºé—´ ç±» TextureLoader"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoDisplay.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoDisplay.html",
    "title": "HoveredItemInfoDisplay ç±» | ProjectStack",
    "keywords": "HoveredItemInfoDisplay ç±» å‘½åç©ºé—´ ProjectStack.UserInterface ç¨‹åºé›† ProjectStack.dll public class HoveredItemInfoDisplay ç»§æ‰¿ object HoveredItemInfoDisplay æ„é€ å‡½æ•° HoveredItemInfoDisplay(IServiceCollection) public HoveredItemInfoDisplay(IServiceCollection services) å‚æ•° services IServiceCollection å±æ€§ HoveredItemInfoProviders public List<HoveredItemInfoProvider> HoveredItemInfoProviders { get; } å±æ€§å€¼ List<HoveredItemInfoProvider> HoveredItemInfoTexts public IImmutableList<string> HoveredItemInfoTexts { get; } å±æ€§å€¼ IImmutableList<string> HoveredItems public ObservableCollection<Node> HoveredItems { get; } å±æ€§å€¼ ObservableCollection<Node>"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoDisplayRegistrationHelper.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoDisplayRegistrationHelper.html",
    "title": "HoveredItemInfoDisplayRegistrationHelper ç±» | ProjectStack",
    "keywords": "HoveredItemInfoDisplayRegistrationHelper ç±» å‘½åç©ºé—´ ProjectStack.UserInterface ç¨‹åºé›† ProjectStack.dll public class HoveredItemInfoDisplayRegistrationHelper ç»§æ‰¿ object HoveredItemInfoDisplayRegistrationHelper æ„é€ å‡½æ•° HoveredItemInfoDisplayRegistrationHelper(IServiceCollection) public HoveredItemInfoDisplayRegistrationHelper(IServiceCollection services) å‚æ•° services IServiceCollection æ–¹æ³• End() public IServiceCollection End() è¿”å› IServiceCollection RegisterHoveredItemInfoProvider(HoveredItemInfoProvider) public HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(HoveredItemInfoProvider hoveredItemInfoProvider) å‚æ•° hoveredItemInfoProvider HoveredItemInfoProvider è¿”å› HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(string, Predicate<HoveredItemInfoDisplay>, Func<HoveredItemInfoDisplay, string>) public HoveredItemInfoDisplayRegistrationHelper RegisterHoveredItemInfoProvider(string providerName, Predicate<HoveredItemInfoDisplay> predicate, Func<HoveredItemInfoDisplay, string> displayTextProvider) å‚æ•° providerName string predicate Predicate<HoveredItemInfoDisplay> displayTextProvider Func<HoveredItemInfoDisplay, string> è¿”å› HoveredItemInfoDisplayRegistrationHelper"
  },
  "api/ProjectStack.UserInterface.HoveredItemInfoProvider.html": {
    "href": "api/ProjectStack.UserInterface.HoveredItemInfoProvider.html",
    "title": "HoveredItemInfoProvider ç±» | ProjectStack",
    "keywords": "HoveredItemInfoProvider ç±» å‘½åç©ºé—´ ProjectStack.UserInterface ç¨‹åºé›† ProjectStack.dll public class HoveredItemInfoProvider ç»§æ‰¿ object HoveredItemInfoProvider æ„é€ å‡½æ•° HoveredItemInfoProvider(string, Predicate<HoveredItemInfoDisplay>, Func<HoveredItemInfoDisplay, string>) public HoveredItemInfoProvider(string providerName, Predicate<HoveredItemInfoDisplay> predicate, Func<HoveredItemInfoDisplay, string> displayTextProvider) å‚æ•° providerName string predicate Predicate<HoveredItemInfoDisplay> displayTextProvider Func<HoveredItemInfoDisplay, string> å±æ€§ ProviderName public string ProviderName { get; } å±æ€§å€¼ string æ–¹æ³• ProvideHoveredItemInfo(HoveredItemInfoDisplay) public string? ProvideHoveredItemInfo(HoveredItemInfoDisplay hoveredItemInfoDisplay) å‚æ•° hoveredItemInfoDisplay HoveredItemInfoDisplay è¿”å› string"
  },
  "api/ProjectStack.UserInterface.html": {
    "href": "api/ProjectStack.UserInterface.html",
    "title": "ProjectStack.UserInterface å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.UserInterface å‘½åç©ºé—´ ç±» HoveredItemInfoDisplay HoveredItemInfoDisplayRegistrationHelper HoveredItemInfoProvider"
  },
  "api/ProjectStack.Util.FileSystemHelper.html": {
    "href": "api/ProjectStack.Util.FileSystemHelper.html",
    "title": "FileSystemHelper ç±» | ProjectStack",
    "keywords": "FileSystemHelper ç±» å‘½åç©ºé—´ ProjectStack.Util ç¨‹åºé›† ProjectStack.dll public class FileSystemHelper ç»§æ‰¿ object FileSystemHelper å±æ€§ Default public static FileSystemHelper Default { get; } å±æ€§å€¼ FileSystemHelper æ–¹æ³• GetAllFilesInDirectory(string) public IEnumerable<string> GetAllFilesInDirectory(string directoryPath) å‚æ•° directoryPath string è¿”å› IEnumerable<string>"
  },
  "api/ProjectStack.Util.html": {
    "href": "api/ProjectStack.Util.html",
    "title": "ProjectStack.Util å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack.Util å‘½åç©ºé—´ ç±» FileSystemHelper"
  },
  "api/ProjectStack.html": {
    "href": "api/ProjectStack.html",
    "title": "ProjectStack å‘½åç©ºé—´ | ProjectStack",
    "keywords": "ProjectStack å‘½åç©ºé—´ ç±» CardTest Game Launcher Main"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | ProjectStack",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | ProjectStack",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | ProjectStack",
    "keywords": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}